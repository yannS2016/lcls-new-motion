<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionStageNC" Id="{27a9489d-ed3b-4885-89cd-bbc7b70f9440}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'call_after_init'}
FUNCTION_BLOCK FB_MotionStageNC IMPLEMENTS I_MotionStage
VAR
    iMotionLogger : I_MotionLogger;
    {attribute 'no_copy'}
    AxisRef : REFERENCE TO AXIS_REF;
   {attribute 'pytmc' := 'pv:'}
    stMotionCommand : ST_MotionCommand;
    // Misc axis status information for the IOC
    {attribute 'pytmc' := '
        pv: PLC:AxisStatus
        io: i
        field: DESC Axis motion status.
    '}
    stMotionStatus: ST_MotionStatus;
   {attribute 'hide'}
   {attribute 'pytmc' := 'pv:'}
	stExMotionStatus : ST_ExtendedMotionStatus;
   {attribute 'hide'}
    iPersistentDataStorage : I_PersistentDataStorage;

    //Brakes : brake fb participate in sync comm with fbMotionDrive, fbMotionAxis and fbMotionInterlocks
    fbBrake : FB_BrakeNC := (BrakeMode := E_StageBrakeMode.IF_MOVING);
    // common interlocks
	{attribute 'pytmc' := 'pv:'}
    fbMotionInterlocksCommon : FB_MotionInterlocksCommon(
		iMotionLogger := iMotionLogger, 
	);
    // stage with Limit switches
    fbLimSwStatus : FB_LimSwStatus();
	
    fbMotionInterlocksLimSw : FB_MotionInterlocksLimSw ( 
		iMotionInterlocksCommon:=fbMotionInterlocksCommon, 
		iLimSwStatus:=fbLimSwStatus,
		iMotionLogger := iMotionLogger
	);
	
	fbHome : FB_HomeNC(
        AxisRef := AxisRef,
        iMotionLogger := iMotionLogger,
        iLimSwStatus := fbLimSwStatus
    );

    fbHalt : FB_HaltNC(
		AxisRef := AxisRef,
		iMotionLogger := iMotionLogger
	);
	
    fbPower : FB_PowerNC(
		AxisRef := AxisRef,
		iMotionLogger := iMotionLogger
	);
	
    fbReset : FB_ResetNC(
		AxisRef := AxisRef,
		iMotionLogger := iMotionLogger
	);
	
    fbMoveAbsolute : FB_MoveAbsoluteNC(
		AxisRef := AxisRef,
		iMotionLogger := iMotionLogger
	);
	
    {attribute 'pytmc' := 'pv:'}
    fbReadParameter : FB_ReadParameterNC(
		AxisRef := AxisRef,
		iMotionLogger := iMotionLogger
	);
    fbWriteParameter : FB_WriteParameterNC(
		AxisRef := AxisRef, 
		iMotionLogger := iMotionLogger
	);
	
    fbParamsSaveRestore : FB_ParamsSaveRestoreNC(
        AxisRef := AxisRef,
        iPersistentDataStorage := iPersistentDataStorage,
		iMotionLogger := iMotionLogger
    );

    {attribute 'pytmc' := 'pv:'}
    fbEncoderScaling : FB_EncoderScaling();

    {attribute 'pytmc' := 'pv:'}
    fbBacklashCompensation : FB_BacklashCompensationNC(
		AxisRef := AxisRef, 
		iMotionLogger := iMotionLogger
	);
	
	{attribute 'pytmc' := 'pv:'}
    fbMotionAxis : FB_MotionAxisNC(
		AxisRef := AxisRef,
		iMotionLogger := iMotionLogger,
        iHome := fbHome,
        iHalt := fbHalt,
        iPower := fbPower,
        iReset := fbReset,
        iMoveAbsolute := fbMoveAbsolute,
        iReadParameter := fbReadParameter,
        iWriteParameter  := fbWriteParameter,
        iParamsSaveRestore:= fbParamsSaveRestore,
        iEncoderScaling := fbEncoderScaling,
        iBacklashCompensation :=fbBacklashCompensation,
    );
		// Motion Requests
	{attribute 'pytmc' := 'pv:'}
    fbMoveRequest : FB_EpicsMoveRequest(
		stMotionCommand:=stMotionCommand,
		stMotionStatus:=stMotionStatus
	);

    fbStateMachine  : FB_MotionDriveStateMachine(
		    stMotionCommand:=stMotionCommand,
            iMotionAxis:=fbMotionAxis,
            iMoveRequest:=fbMoveRequest,
			iMotionLogger := iMotionLogger
    );
    // Name to use for log messages, fast faults, etc.
    {attribute 'hide'}
    sName : T_MaxString;
    {attribute 'hide'}
    bError : BOOL;
    {attribute 'hide'}
    nErrorId : UDINT;
    {attribute 'hide'}
    sErrorMessage : STRING;
    {attribute 'hide'}
	rtRestoreDone : R_TRIG;
    {attribute 'hide'}
    rtStop : R_TRIG;
    {attribute 'hide'}
    ftstop: F_TRIG;
	bHandleHalt : BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// 1. Coordination/orchestration logic; these now use status from axis/interlocks
HandleMoveRequest();
// 2. High-level coordination blocks (requests, state machine, brake)
fbMoveRequest();
// 3. Send Request status to interlocks
SendRequestStatusToInterlocks();

// 4. Read hardware limit switches (always first)
fbLimSwStatus();
// 3. Interlocks: update with latest axis status
fbMotionInterlocksCommon();
fbMotionInterlocksLimSw();

HandleHalt();
HandleReset();
HandlePowerControl();
// 2. Axis block — calls all its internal NC FBs and aggregates status
fbReset();
fbHalt();
fbPower();
fbBacklashCompensation();
fbMoveAbsolute();
fbHome();
fbReadParameter();
fbWriteParameter();
fbParamsSaveRestore();
fbEncoderScaling();
fbMotionAxis();
 
//-- Interlocks: update with latest axis status
UpdateInterlockAxisStatus();

HandleStateMachine();
fbStateMachine();
fbBrake();
// Periodic parameter read/save, if required
ReadAndSaveAxisParameters();
HandleErrorPropagation();
// Diagnostics/EPICS status block (always last)
UpdateMotionInterfaceStatus();
//
RestoreSettings();]]></ST>
    </Implementation>
    <Method Name="AbsoluteMove" Id="{6b96bfb8-b32d-4334-81ff-c0392805e3a2}">
      <Declaration><![CDATA[METHOD AbsoluteMove
VAR_INPUT
	Position :LREAL;
	Velocity :LREAL;
	Acceleration :LREAL;
	Deceleration :LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[stMotionCommand.fPosition := Position;
stMotionCommand.fVelocity := Velocity;
stMotionCommand.fAcceleration := Acceleration;
stMotionCommand.fDeceleration := Deceleration;
stMotionCommand.fDeceleration := Deceleration;
stMotionCommand.bMoveCmd := TRUE;
//stMotionInterface.bExecute:=TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="AbsoluteMoveWithBacklashCompensation" Id="{f62f2af9-f0af-4e16-9630-d424e844c1e4}">
      <Declaration><![CDATA[{warning 'Add method implementation '}
METHOD AbsoluteMoveWithBacklashCompensation
VAR_INPUT
	Position	: LREAL;
	Velocity	: LREAL;
	Acceleration	: LREAL;
	Deceleration	: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ AbsoluteMove(	
	Position	:= Position,
	Velocity	:= Velocity,
	Acceleration	:= Acceleration,
	Deceleration	:= Deceleration
);
fbBacklashCompensation.BacklashCompensation(Enable := TRUE, RampVelo := Velocity/10.0);]]></ST>
      </Implementation>
    </Method>
    <Method Name="CallAfterInit" Id="{e7a5e1c3-8324-4257-a302-ab714cb009e4}">
      <Declaration><![CDATA[{attribute 'call_after_init'}
METHOD PRIVATE CallAfterInit]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMotionInterlocksCommon.CallAfterInit(
	iMotionLogger := THIS^.iMotionLogger, 
);
//fbLimSwStatus.CallAfterInit(iMotionLogger := THIS^.iMotionLogger);
fbMotionInterlocksLimSw.CallAfterInit(
	iMotionInterlocksCommon := THIS^.fbMotionInterlocksCommon,
	iLimSwStatus := THIS^.fbLimSwStatus,
	iMotionLogger := THIS^.iMotionLogger
);

// Pass correctly initialized Motion axis dependencies
fbHome.CallAfterInit(
        AxisRef := THIS^.AxisRef,
        iMotionLogger := THIS^.iMotionLogger,
        iLimSwStatus := THIS^.fbLimSwStatus
);

fbHalt.CallAfterInit(
	AxisRef := THIS^.AxisRef,
	iMotionLogger := THIS^.iMotionLogger
);

fbPower.CallAfterInit(
	AxisRef := THIS^.AxisRef,
	iMotionLogger := iMotionLogger
);

fbReset.CallAfterInit(
	AxisRef := THIS^.AxisRef,
	iMotionLogger := THIS^.iMotionLogger
);

fbMoveAbsolute.CallAfterInit(
	AxisRef := THIS^.AxisRef,
	iMotionLogger := THIS^.iMotionLogger
);

fbReadParameter.CallAfterInit(
	AxisRef := THIS^.AxisRef,
	iMotionLogger := THIS^.iMotionLogger
);

fbWriteParameter.CallAfterInit(
	AxisRef := THIS^.AxisRef,
	iMotionLogger := THIS^.iMotionLogger
);

fbParamsSaveRestore.CallAfterInit(
	AxisRef := THIS^.AxisRef,
	iPersistentDataStorage := THIS^.iPersistentDataStorage,
	iMotionLogger := THIS^.iMotionLogger
);

fbBacklashCompensation.CallAfterInit(
	AxisRef := THIS^.AxisRef,
	iMotionLogger := THIS^.iMotionLogger
);

fbMotionAxis.CallAfterInit(
	AxisRef := THIS^.AxisRef,
	iMotionLogger := THIS^.iMotionLogger,
    iHome := THIS^.fbHome,
    iHalt := THIS^.fbHalt,
    iPower := THIS^.fbPower,
    iReset := THIS^.fbReset,
    iMoveAbsolute := THIS^.fbMoveAbsolute,
    iReadParameter := THIS^.fbReadParameter,
    iWriteParameter  := THIS^.fbWriteParameter,
    iParamsSaveRestore:= THIS^.fbParamsSaveRestore,
    iEncoderScaling := THIS^.fbEncoderScaling,
    iBacklashCompensation := THIS^.fbBacklashCompensation
);


fbMoveRequest.CallAfterInit(
	stMotionCommand:= THIS^.stMotionCommand,
	stMotionStatus:= THIS^.stMotionStatus
);

fbStateMachine.CallAfterInit(
	iMotionAxis:=THIS^.fbMotionAxis, 
	iMoveRequest:=THIS^.fbMoveRequest, 
	stMotionCommand:=THIS^.stMotionCommand,
	iMotionLogger := THIS^.iMotionLogger
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableBacklashCompensation" Id="{87740abd-9537-43e7-9863-d2436efc09c8}">
      <Declaration><![CDATA[METHOD INTERNAL EnableBacklashCompensation
VAR_INPUT
    UserEnable : BOOL;
    Compensation : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbMotionAxis.EnableBacklashCompensation(UserEnable:=UserEnable, Compensation:=Compensation);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableInterlocks" Id="{01e88651-9d49-4945-987c-423a0e3265de}">
      <Declaration><![CDATA[METHOD INTERNAL EnableInterlocks : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.fbMotionInterlocksCommon.EnableInterlocks(
	UserEnable:=TRUE, 
	HardwareEnable:=TRUE
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableLimits" Id="{a4eaf3aa-cc7c-4de6-ad38-357755265135}">
      <Declaration><![CDATA[METHOD INTERNAL EnableLimits
VAR_INPUT
	ForwardEnable : BOOL;
	BackwardEnable : BOOL;
	HomeEnable : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbLimSwStatus.LimitBackwardEnable := BackwardEnable;
fbLimSwStatus.LimitForwardEnable:=ForwardEnable;
fbLimSwStatus.LimitHome := HomeEnable ;]]></ST>
      </Implementation>
    </Method>
    <Property Name="ExMotionStatus" Id="{128987fe-11fc-46a5-8fc4-06563e725a71}">
      <Declaration><![CDATA[PROPERTY ExMotionStatus : REFERENCE TO ST_ExtendedMotionStatus
]]></Declaration>
      <Get Name="Get" Id="{1f210a80-eafc-4a4f-ad0e-cb6763b7d812}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ExMotionStatus REF= stExMotionStatus;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_Init" Id="{fe4c9de1-abf0-4550-ae13-2cd56df378be}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
    iMotionLogger : I_MotionLogger;
    AxisRef : REFERENCE TO AXIS_REF;
    iPersistentDataStorage : I_PersistentDataStorage;
    sName : T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iMotionLogger := iMotionLogger;
THIS^.AxisRef REF= AxisRef;
THIS^.iPersistentDataStorage := iPersistentDataStorage;
THIS^.sName := sName;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Halt" Id="{2c901b2a-83fd-4fc2-92b8-e5d871ebacc1}">
      <Declaration><![CDATA[METHOD Halt
]]></Declaration>
      <Implementation>
        <ST><![CDATA[stMotionCommand.bExecute:=FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleErrorPropagation" Id="{e9cb52b1-0a2d-4fed-aabd-a100b735fbf3}">
      <Declaration><![CDATA[METHOD PRIVATE HandleErrorPropagation

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF fbMotionAxis.Status.bError THEN
    bError := fbMotionAxis.Status.bError;
    nErrorId := fbMotionAxis.Status.nErrorID;
    sErrorMessage := fbMotionAxis.Status.sMessage;
ELSIF fbMotionInterlocksCommon.Error THEN
    bError := fbMotionInterlocksCommon.Error;
    nErrorId := fbMotionInterlocksCommon.ErrorID;
    sErrorMessage := fbMotionInterlocksCommon.Message;
ELSIF fbMotionInterlocksLimSw.Warning THEN
    THIS^.bError := FALSE;
    THIS^.nErrorId := 0;
    THIS^.sErrorMessage := fbMotionInterlocksLimSw.Message;
ELSE
    THIS^.bError := FALSE;
    THIS^.nErrorId := 0;
    THIS^.sErrorMessage := '';
END_IF
 
fbMoveRequest.MoveRequestError(
    Error := THIS^.bError,
    ErrorId := THIS^.nErrorId,
    ErrorMessage := THIS^.sErrorMessage
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleHalt" Id="{90c9a875-6d6e-4f45-a0af-4ce30421ce05}">
      <Declaration><![CDATA[METHOD PRIVATE HandleHalt : BOOL

]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Halt is always a user stop but not an interlock event or a reset.
ftstop(CLK:=stMotionCommand.bExecute);

bHandleHalt := NOT stMotionCommand.bReset AND ftstop.Q
                        AND ((fbMotionAxis.Status.bBusy AND (fbMoveRequest.Status.nCommand=10))
                        OR (fbMotionAxis.Status.bBusy AND (fbMoveRequest.Status.nCommand=3)));
rtStop(CLK := bHandleHalt );

IF rtStop.Q THEN
	IF fbHome.Busy THEN
		fbHome.StopHome();
	END_IF
    fbHalt.Halt(Deceleration := stMotionCommand.fDeceleration);
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleMoveRequest" Id="{37d9518e-1194-4c89-95b2-43e2fec1cf96}">
      <Declaration><![CDATA[METHOD PRIVATE HandleMoveRequest
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMoveRequest.MoveRequest(
	EnableDone := fbMotionAxis.AxisEnabled(),
	MoveOk := fbMotionInterlocksLimSw.MoveOk
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandlePowerControl" Id="{bd0f7b6d-979a-4acc-99e2-0b04fce36ff8}">
      <Declaration><![CDATA[METHOD PRIVATE HandlePowerControl
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMotionAxis.Power(
    Enable           := fbMotionInterlocksLimSw.PowerEnabled,
    Enable_Positive  := fbMoveRequest.Status.bExecHome OR fbMotionInterlocksLimSw.MoveForwardEnabled,
    Enable_Negative  := fbMoveRequest.Status.bExecHome OR fbMotionInterlocksLimSw.MoveBackwardEnabled,
    Override         := 100.0,
    BufferMode       := MC_Aborting
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleReset" Id="{b2968e94-a3b3-4e1f-9c6c-65539662a9c5}">
      <Declaration><![CDATA[METHOD PRIVATE HandleReset
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stMotionCommand.bReset THEN
    fbMoveRequest.ClearMoveRequest();
    fbMoveRequest.ClearMoveRequestErrors();
    stMotionCommand.bReset := FALSE;
    fbReset.Reset();
    fbMotionInterlocksLimSw.Reset();
	fbStateMachine.Reset();
	IF fbHome.Busy THEN
		fbHome.StopHome();
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="HandleStateMachine" Id="{e30304c4-f237-4971-8276-058981530526}">
      <Declaration><![CDATA[METHOD PRIVATE HandleStateMachine
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbStateMachine.StateMachine(
    Error := THIS^.bError
);
fbBrake.AxisState := fbMotionAxis.Status.eAxisState;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Home" Id="{a2ae8eea-a6b7-4c20-82db-35228737cd92}">
      <Declaration><![CDATA[METHOD Home
VAR_INPUT
	HomePosition	: LREAL;
	HomeMode	: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.stMotionCommand.fHomePosition := HomePosition;
THIS^.stMotionCommand.nCmdData := HomeMode;
THIS^.stMotionCommand.bHomeCmd := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="MotionCmd" Id="{cff885f3-b2ab-45e5-a718-4e59c9412c91}">
      <Declaration><![CDATA[PROPERTY MotionCmd : REFERENCE TO ST_MotionCommand
]]></Declaration>
      <Get Name="Get" Id="{90db2be8-cd32-4e3f-90bd-a14ca62895a8}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[MotionCmd REF= stMotionCommand;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="MotionStatus" Id="{c60f6c35-3f3b-4a35-9111-e841cc53b467}">
      <Declaration><![CDATA[{warning 'Add property implementation'}
PROPERTY MotionStatus : REFERENCE TO ST_MotionStatus
]]></Declaration>
      <Get Name="Get" Id="{fdf66257-32b2-45e6-ab38-2579c576b03c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[MotionStatus REF= stMotionStatus;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="ReadAndSaveAxisParameters" Id="{f5c81eda-b6b7-4217-af83-eabbc46c0ac6}">
      <Declaration><![CDATA[METHOD PRIVATE ReadAndSaveAxisParameters
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMotionAxis.ReadAxisParams(
    Enable := TRUE,
    RefreshDelay := T#1S
);
 
fbMotionAxis.SaveAxisParams(Enable := TRUE);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{d755df2f-0cbd-4c37-abcb-c15d293d7377}">
      <Declaration><![CDATA[{warning 'Add method implementation '}
METHOD Reset
]]></Declaration>
      <Implementation>
        <ST><![CDATA[stMotionCommand.bReset:=TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="RestoreSettings" Id="{2dee1569-47ee-484d-bba0-b50581ae3c52}">
      <Declaration><![CDATA[METHOD PRIVATE RestoreSettings
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// no needed in production since the actualposition is already set on the axis
// and epics status will get that last position
// use this to restore anything thats not an axisref paramter.
rtRestoreDone(CLK:= THIS^.fbMotionAxis.Status.bRestoreDone);
IF rtRestoreDone.Q THEN
    THIS^.stMotionCommand.fPosition := THIS^.fbMotionAxis.Status.fSavedPosition;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SendRequestStatusToInterlocks" Id="{de44592c-bd13-4b62-b6bf-ebf407d3bbaa}">
      <Declaration><![CDATA[METHOD PRIVATE SendRequestStatusToInterlocks
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMotionInterlocksLimSw.DriveCommands(
    MoveEnable := fbMoveRequest.Status.bEnable,
    NewMoveReq := fbMoveRequest.Status.bNewMoveReq
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetModeEnableLimits" Id="{98961738-8245-4a6d-ad83-dbba42b21c0d}">
      <Declaration><![CDATA[METHOD INTERNAL SetModeEnableLimits
VAR_INPUT  
	LimBackward : BOOL; 
	LimForward: BOOL; 
	BrakeMode : E_StageBrakeMode; 
	EnableMode: ENUM_StageEnableMode; 
	HomeMode: E_EpicsHomeCmd;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMove" Id="{56faff5b-6abb-4b77-9cef-4400d53a7eb1}">
      <Declaration><![CDATA[METHOD StateMove
VAR_INPUT
	Execute : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[stMotionCommand.bExecute := Execute;]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateInterlockAxisStatus" Id="{ee152f48-cf6d-48de-87b2-feac022c8dfd}">
      <Declaration><![CDATA[METHOD PRIVATE UpdateInterlockAxisStatus
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMotionInterlocksLimSw.AxisStatus(
    HomeBusy           := fbMotionAxis.Status.bHomeBusy,
    PositiveDirection  := fbMotionAxis.Status.bPositiveMotionIsEnabled,
    NegativeDirection  := fbMotionAxis.Status.bNegativeMotionIsEnabled
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateInterlockUserEnable" Id="{c607da76-5703-454d-b750-0323f82d2b59}">
      <Declaration><![CDATA[METHOD PRIVATE UpdateInterlockUserEnable
VAR_INPUT
	UserEnable : BOOL;
	HardwareEnable : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMotionInterlocksCommon.EnableInterlocks(
	UserEnable:=UserEnable,
	HardwareEnable:=HardwareEnable
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateMotionInterfaceStatus" Id="{d66d426b-be69-4f86-acf2-a262bf3e8386}">
      <Declaration><![CDATA[METHOD PRIVATE UpdateMotionInterfaceStatus
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[stMotionStatus.nMotionAxisID := fbMotionAxis.Status.nAxisId;
stMotionStatus.bEnabled    := fbMotionInterlocksLimSw.PowerEnabled;
stMotionStatus.bHomeSensor := fbMotionInterlocksLimSw.LimHome;
stMotionStatus.bLimitBwd   := fbMotionInterlocksLimSw.MoveBackwardEnabled;
stMotionStatus.bLimitFwd   := fbMotionInterlocksLimSw.MoveForwardEnabled;
stMotionStatus.fActDiff    := fbMotionAxis.Status.fMeasuredPositionDiff;
stMotionStatus.fActPosition:= fbMotionAxis.Status.fMeasuredPosition;
stMotionStatus.fActVelocity:= fbMotionAxis.Status.fMeasuredVelocity;
stMotionStatus.fOverride   := fbMotionAxis.Status.fPowerOverride;
stMotionStatus.bBusy       := fbMotionAxis.Status.bBusy;
stMotionStatus.bHomed      := fbMotionAxis.Status.bHomeDone;
//stMotionStatus.bDone       := fbMotionAxis.Status.bDone;
stMotionStatus.bError      := THIS^.bError;
stMotionStatus.nErrorId    := THIS^.nErrorId;
stMotionStatus.sErrorMessage:= THIS^.sErrorMessage;

// Usefull for debugging and unit tests
stExMotionStatus.bMotionAxisError := fbMotionAxis.Status.bError;
stExMotionStatus.nMotionAxisErrorId := fbMotionAxis.Status.nErrorID;
stExMotionStatus.bInterlocksError := fbMotionInterlocksCommon.Error;
stExMotionStatus.nInterlocksError := fbMotionInterlocksCommon.ErrorID;
stExMotionStatus.eDriveState := fbStateMachine.MoveState;
stExMotionStatus.bAbortDone  := fbMotionAxis.Status.bAbortDone;
stExMotionStatus.bAborted :=  fbMotionAxis.Status.bAborted;
stExMotionStatus.bLimHomeDone := fbMotionAxis.Status.bLimHomeDone;
stExMotionStatus.bDriveWatchDogStatus := fbStateMachine.WatchDogStatus;
stExMotionStatus.bNewMoveReq := fbMoveRequest.Status.bNewMoveReq;
stExMotionStatus.bEnable := fbMoveRequest.Status.bEnable;
stExMotionStatus.bIdling:= fbStateMachine.Idling;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>