<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionAxisNC" Id="{b2082997-3f19-4e96-8959-1acebaf0fbc0}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotionAxisNC IMPLEMENTS I_MotionAxis
VAR
	{attribute 'no_copy'}
	AxisRef : REFERENCE TO AXIS_REF; // main axis reference
	iHome : I_Home;
    iHalt : I_Halt;
    iPower : I_Power;
    iReset : I_Reset;
    iMoveAbsolute : I_MoveAbsolute;
    iReadParameter : I_ReadParameter;
    iWriteParameter  : I_WriteParameter;
    iParamsSaveRestore: I_ParamsSaveRestore;
    iEncoderScaling : I_EncoderScaling;
    iAxisStatus : I_AxisStatus;
    iBacklashCompensation : I_BacklashCompensation;
    iMotionLogger : I_MotionLogger := 0; // logger interface, optional

    // Axis status and error aggregation
    bError : BOOL := FALSE;
    nErrorID : UDINT := 0;
    sMessage : T_MAXSTRING := '';

    // Triggers for error/abort conditions
    rtAbortDone : R_TRIG;
    rtMoveAbsoluteError : R_TRIG;
    rtHaltError : R_TRIG;
    rtResetError : R_TRIG;

    // Aggregated axis status structure
    stMotionAxisStatus : ST_AxisStatus;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[// 0. Validate reference first
IF NOT __ISVALIDREF(AxisRef) THEN
    bError := TRUE;
    nErrorID := 999;
    RETURN;
END_IF

// 1. Read axis hardware status *FIRST*
AxisRef.ReadStatus();



// 3. Error Handling — now FBs' error/status are up-to-date
ErrorHandling();

// 4. Update outputs/status
stMotionAxisStatus.bAbortDone                := iHalt.Done OR iReset.Done;
stMotionAxisStatus.bAborted                  := iMoveAbsolute.Aborted;
stMotionAxisStatus.bAxisEnable               := AxisEnabled();
stMotionAxisStatus.bAxisReadParamsInit       := iReadParameter.AxisReadParamsInit;
stMotionAxisStatus.eAxisState                := AxisRef.Status.MotionState;
stMotionAxisStatus.bBacklashCompensationStatus := iBacklashCompensation.Status;
stMotionAxisStatus.bHaltActive               := iHalt.Active;
stMotionAxisStatus.bHaltBusy                 := iHalt.Busy;
stMotionAxisStatus.bHaltDone                 := iHalt.Done;
stMotionAxisStatus.bHomeBusy                 := iHome.Busy;
stMotionAxisStatus.bHomeDone                 := iHome.Done;
stMotionAxisStatus.bLimHomeDone              := iHome.LimHomeDone;
stMotionAxisStatus.eHomeMode                 := iHome.Mode;
stMotionAxisStatus.bInTargetPosition         := AxisRef.Status.InTargetPosition;
stMotionAxisStatus.nAxisId                   := AxisRef.NcToPlc.AxisId;
stMotionAxisStatus.fMeasuredAcceleration     := AxisRef.NcToPlc.ActAcc;
stMotionAxisStatus.fMeasuredCompensation     := iBacklashCompensation.CurrentBacklash;
stMotionAxisStatus.fMeasuredPosition         := AxisRef.NcToPlc.ActPos;
stMotionAxisStatus.fMeasuredPositionDiff     := AxisRef.NcToPlc.PosDiff;
stMotionAxisStatus.fMeasuredVelocity         := AxisRef.NcToPlc.ActVelo;
stMotionAxisStatus.sMessage                  := sMessage;
stMotionAxisStatus.bMoveAbsoluteAborted      := iMoveAbsolute.Aborted;
stMotionAxisStatus.bMoveAbsoluteActive       := iMoveAbsolute.Active;
stMotionAxisStatus.bMoveAbsoluteBusy         := iMoveAbsolute.Busy;
stMotionAxisStatus.bMoveAbsoluteDone         := iMoveAbsolute.Done;
stMotionAxisStatus.bNegativeMotionIsEnabled  := AxisRef.Status.NegativeDirection;
stMotionAxisStatus.bPositiveMotionIsEnabled  := AxisRef.Status.PositiveDirection;
stMotionAxisStatus.bDirectionalPowerEnabled  := iPower.DirectionalPowerEnabled;
stMotionAxisStatus.bPowerActive              := iPower.PowerIsEnabled;
stMotionAxisStatus.fPowerOverride            := iPower.Override;
stMotionAxisStatus.bResetBusy                := iReset.Busy;
stMotionAxisStatus.bResetDone                := iReset.Done;
stMotionAxisStatus.bRestoreDone              := iParamsSaveRestore.Done;
stMotionAxisStatus.fSavedPosition            := iParamsSaveRestore.SavedPosition;
stMotionAxisStatus.nScaledEncoderCount       := iEncoderScaling.EncoderCount;
stMotionAxisStatus.bStandStill               := AxisRef.Status.StandStill;
stMotionAxisStatus.bBusy                     := iHome.Busy OR iMoveAbsolute.Busy;
stMotionAxisStatus.bDone                     := iHome.Done OR iMoveAbsolute.Done;
stMotionAxisStatus.bError                    := bError;
stMotionAxisStatus.nErrorID                  := nErrorID;

// 5. Auto-reset triggers for internal error recovery
rtMoveAbsoluteError(CLK:=iMoveAbsolute.Error);
rtHaltError(CLK:=iHalt.Error);
rtResetError(CLK:=iReset.Error);

IF rtMoveAbsoluteError.Q THEN
    iMoveAbsolute.MoveAbsoluteDone();    
ELSIF rtHaltError.Q THEN
    iHalt.HaltDone();    
ELSIF rtResetError.Q THEN
    iReset.ResetDone();    
END_IF]]></ST>
    </Implementation>
    <Method Name="AxisEnabled" Id="{cc4bbafd-6987-498c-9fa8-c674abc392f5}">
      <Declaration><![CDATA[METHOD AxisEnabled : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Get a definitive bEnabled reading
CASE THIS^.AxisRef.Status.MotionState OF
    // We are not enabled if there is an issue
    MC_AXISSTATE_UNDEFINED, MC_AXISSTATE_DISABLED, MC_AXISSTATE_ERRORSTOP:
        AxisEnabled := FALSE;
    ELSE
        AxisEnabled := TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="BacklashCompensation" Id="{47b7a29c-5a46-4b34-82e5-46809c891caa}">
      <Declaration><![CDATA[(*
    Handle positive/negative backlash compensation
    User needs to set the direction of backlash from the sign of the compensation value
    Backlash compensation is disabled during referencing (homing).
    When direction is positive/negative, further movement in the negative/positive direction not compensated
    further movement in the negative/positive direction will be compensated
*)
METHOD BacklashCompensation
VAR_INPUT
    Enable : BOOL := FALSE;
    RampVelo : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iBacklashCompensation.BacklashCompensation(	Enable:=Enable,
                                                    RampVelo:=RampVelo
                                                );

 ]]></ST>
      </Implementation>
    </Method>
    <Method Name="CallAfterInit" Id="{9b35c028-bf1f-45b2-b785-efd534d69557}">
      <Declaration><![CDATA[METHOD PUBLIC CallAfterInit
VAR_INPUT
	AxisRef : REFERENCE TO AXIS_REF; // main axis reference
	iMotionLogger : I_MotionLogger;
    iHome : I_Home;
    iHalt : I_Halt;
    iPower : I_Power;
    iReset : I_Reset;
    iMoveAbsolute : I_MoveAbsolute;
    iReadParameter : I_ReadParameter;
    iWriteParameter  : I_WriteParameter;
    iParamsSaveRestore: I_ParamsSaveRestore;
    iEncoderScaling : I_EncoderScaling;
    iBacklashCompensation : I_BacklashCompensation;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.AxisRef REF= AxisRef;
THIS^.iMotionLogger := iMotionLogger;
THIS^.iHome := iHome;
THIS^.iHalt := iHalt;
THIS^.iPower := iPower;
THIS^.iReset := iReset;
THIS^.iMoveAbsolute := iMoveAbsolute;
THIS^.iReadParameter := iReadParameter ;
THIS^.iWriteParameter  := iWriteParameter;
THIS^.iParamsSaveRestore:= iParamsSaveRestore;
THIS^.iEncoderScaling := iEncoderScaling;
THIS^.iBacklashCompensation  := iBacklashCompensation ;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="DisablePower" Id="{d431613d-dd04-4413-bd5f-ff595b13e90c}">
      <Declaration><![CDATA[METHOD DisablePower
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iPower.DisablePower();]]></ST>
      </Implementation>
    </Method>
    <Method Name="DriveCommands" Id="{b8507c31-2c0f-4ad7-a181-843fb8302b04}">
      <Declaration><![CDATA[METHOD DriveCommands
VAR_INPUT
    HomeCmd	: BOOL;
    NewMoveReq	: BOOL;
    EnableMode	: E_StageEnableMode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableBacklashCompensation" Id="{efdf6621-04bc-4c66-aa33-43b9ca53e1d5}">
      <Declaration><![CDATA[METHOD  EnableBacklashCompensation
VAR_INPUT
    UserEnable : BOOL;
    Compensation : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iBacklashCompensation.EnableBacklashCompensation(UserEnable:=UserEnable, Compensation:=Compensation);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ErrorHandling" Id="{47e04ad9-0158-4554-a680-9fdc3b3acad9}">
      <Declaration><![CDATA[METHOD INTERNAL ErrorHandling
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
    Error from NC functions
    The error will be sent to EPICS interface based on predifined
    priority: axis, power, backlash, absoluteMove, etc...
*)
IF THIS^.iPower.Error AND THIS^.iPower.PowerIsEnabled THEN
    bError:=THIS^.iPower.Error;
    nErrorId:=THIS^.iPower.ErrorID;
    sMessage := THIS^.iPower.Message;
ELSIF THIS^.iHalt.Error AND THIS^.iHalt.Active THEN
    bError:=THIS^.iHalt.Error;
    nErrorId:=THIS^.iHalt.ErrorID;
    sMessage := THIS^.iHalt.Message;
ELSIF THIS^.iReset.Error AND THIS^.iReset.Active THEN
    bError:=THIS^.iReset.Error;
    nErrorId:=THIS^.iReset.ErrorID;
    sMessage := THIS^.iReset.Message;
ELSIF THIS^.iBacklashCompensation.Error THEN
    bError:=THIS^.iBacklashCompensation.Error;
    nErrorId:=THIS^.iBacklashCompensation.ErrorID;
    sMessage := THIS^.iBacklashCompensation.Message;
ELSIF THIS^.iMoveAbsolute.Error THEN
    bError:=THIS^.iMoveAbsolute.Error;
    nErrorId:=THIS^.iMoveAbsolute.ErrorID;
    sMessage := THIS^.iMoveAbsolute.Message;
ELSIF THIS^.iHome.Error (*Homing error*) THEN
    bError:=THIS^.iHome.Error;
    nErrorId:=THIS^.iHome.ErrorID;
    sMessage := THIS^.iHome.Message;
ELSIF THIS^.AxisRef.Status.Error  THEN
    bError:=THIS^.AxisRef.Status.Error;
    nErrorId:=THIS^.AxisRef.Status.ErrorID;
    sMessage := THIS^.iMotionLogger.ErrorCodeLookup(THIS^.AxisRef.Status.ErrorID);
	// dont report this erro if absolute/home move is busy
ELSIF THIS^.iReadParameter.Error 
	AND (NOT THIS^.iMoveAbsolute.Busy OR NOT THIS^.iHome.Busy) THEN
    bError := THIS^.iReadParameter.Error;
    nErrorId := THIS^.iReadParameter.ErrorID;
    sMessage := THIS^.iReadParameter.Message;
ELSIF THIS^.iWriteParameter.Error THEN
    bError := THIS^.iWriteParameter.Error;
    nErrorId := THIS^.iWriteParameter.ErrorID;
    sMessage := THIS^.iWriteParameter.Message;
ELSIF THIS^.iParamsSaveRestore.Error THEN
    bError := THIS^.iParamsSaveRestore.Error;
    nErrorId := THIS^.iParamsSaveRestore.ErrorID;
    sMessage := THIS^.iParamsSaveRestore.Message;
ELSE
    bError:=FALSE;
    nErrorId:=0;
    sMessage := '';
END_IF;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_Init" Id="{3ca36ea2-2fee-4826-a4c8-a0afdd04a31e}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)

	AxisRef : REFERENCE TO AXIS_REF; // main axis reference
	iMotionLogger : I_MotionLogger;
    iHome : I_Home;
    iHalt : I_Halt;
    iPower : I_Power;
    iReset : I_Reset;
    iMoveAbsolute : I_MoveAbsolute;
    iReadParameter : I_ReadParameter;
    iWriteParameter  : I_WriteParameter;
    iParamsSaveRestore: I_ParamsSaveRestore;
    iEncoderScaling : I_EncoderScaling;
    iBacklashCompensation : I_BacklashCompensation;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.AxisRef REF= AxisRef;
THIS^.iMotionLogger := iMotionLogger;
THIS^.iHome := iHome;
THIS^.iHalt := iHalt;
THIS^.iPower := iPower;
THIS^.iReset := iReset;
THIS^.iMoveAbsolute := iMoveAbsolute;
THIS^.iReadParameter := iReadParameter ;
THIS^.iWriteParameter  := iWriteParameter;
THIS^.iParamsSaveRestore:= iParamsSaveRestore;
THIS^.iEncoderScaling := iEncoderScaling;
THIS^.iBacklashCompensation  := iBacklashCompensation ;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Halt" Id="{669b312b-74c8-481c-b6f9-68179672a70f}">
      <Declaration><![CDATA[METHOD Halt
VAR_INPUT
    Deceleration	: LREAL := 0;
    Jerk	: LREAL := 0;
    BufferMode	: MC_BufferMode := MC_BufferMode.MC_Aborting;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iHalt.Halt( 	Deceleration:=Deceleration,
                    Jerk:=Jerk ,
                    BufferMode:=BufferMode );]]></ST>
      </Implementation>
    </Method>
    <Method Name="Home" Id="{19a4a42c-65d0-44c2-9ba0-43e7fa25e791}">
      <Declaration><![CDATA[METHOD Home
VAR_INPUT
    Position        : LREAL         := DEFAULT_HOME_POSITION;
    BufferMode      : MC_BufferMode;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//
THIS^.iHome.Home(Position:=Position,BufferMode:=MC_BufferMode.MC_Aborting);]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAbsolute" Id="{4f09799f-35f4-498c-b47e-65f81ea0c180}">
      <Declaration><![CDATA[METHOD MoveAbsolute
VAR_INPUT
    Position	: LREAL;
    Velocity	: LREAL;
    Acceleration	: LREAL := 0.0;
    Deceleration	: LREAL := 0.0;
    Jerk	: LREAL := 0.0;
    BufferMode	: MC_BufferMode := MC_BufferMode.MC_Aborting;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iMoveAbsolute.MoveAbsolute( 	Position:=Position,
                                       Velocity := Velocity,
                                    Acceleration := Acceleration,
                                    Deceleration := Deceleration,
                                    Jerk := Jerk,
                                    BufferMode := BufferMode);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAbsoluteDone" Id="{127bbfb4-8244-48a3-8c7a-84752ee460fc}">
      <Declaration><![CDATA[METHOD MoveAbsoluteDone
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iMoveAbsolute.MoveAbsoluteDone();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Power" Id="{ec1783df-e1a3-46f4-829a-9762b3ca588d}">
      <Declaration><![CDATA[METHOD Power
VAR_INPUT
    Enable	: BOOL;
    Enable_Positive	: BOOL;
    Enable_Negative	: BOOL;
    Override	: LREAL := 100.0;
    BufferMode	: MC_BufferMode := MC_BufferMode.MC_Aborting;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iPower.Power(	Enable:=Enable,
                    Enable_Positive:= Enable_Positive,
                    Enable_Negative:=Enable_Negative,
                    Override:=Override,
                    BufferMode:=BufferMode
                );]]></ST>
      </Implementation>
    </Method>
    <Method Name="PowerEnables" Id="{9f48c379-e1d3-4087-91db-594e6015e37d}">
      <Declaration><![CDATA[(*This is overriden by this object internal acess to the interlock instance
  this is intended to pass power enable flags via the fbMotionDrive
*)
METHOD PowerEnables
VAR_INPUT
    Enable	: BOOL;
    Enable_Positive	: BOOL;
    Enable_Negative	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iPower.Power(	Enable:=Enable,
                    Enable_Positive:= Enable_Positive,
                    Enable_Negative:=Enable_Negative,
                    Override:=100.0,
                    BufferMode:=MC_BufferMode.MC_Aborting
                );]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadAxisParams" Id="{050cbcc2-33e7-4ef4-8d73-511312ef4239}">
      <Declaration><![CDATA[METHOD ReadAxisParams
VAR_INPUT
    Enable	: BOOL;
    RefreshDelay	: TIME;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iReadParameter.ReadParameters(Enable:=Enable, RefreshDelay:=RefreshDelay);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{1c7b54c7-fc14-4552-871c-6730dd93d7ea}">
      <Declaration><![CDATA[METHOD Reset
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iReset.Reset();]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetDone" Id="{7f0790e9-8e29-4ab4-adcd-e05f727f68d8}">
      <Declaration><![CDATA[METHOD ResetDone
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iReset.ResetDone();]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResetExecute" Id="{10092d88-8263-4453-9e57-d2d8fd2128e6}">
      <Declaration><![CDATA[METHOD ResetExecute
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iHalt.HaltDone();]]></ST>
      </Implementation>
    </Method>
    <Method Name="SaveAxisParams" Id="{e5a35223-1f28-40e0-a094-53d1b9164718}">
      <Declaration><![CDATA[METHOD SaveAxisParams
VAR_INPUT
    Enable	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iParamsSaveRestore.SaveAxisParams(Enable:=Enable);]]></ST>
      </Implementation>
    </Method>
    <Property Name="Status" Id="{e57f34f0-4782-4fdb-b236-ad33acfccad4}">
      <Declaration><![CDATA[PROPERTY Status : REFERENCE TO ST_AxisStatus
]]></Declaration>
      <Get Name="Get" Id="{19f70767-a91a-4512-8e71-3365cb03cfc5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Status REF= stMotionAxisStatus;]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>