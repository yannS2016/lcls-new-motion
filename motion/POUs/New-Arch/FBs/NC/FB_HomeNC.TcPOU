<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_HomeNC" Id="{970a142c-358e-492f-9cec-3782954ac4db}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_HomeNC IMPLEMENTS I_Home
VAR
    {attribute 'no_copy'}
    AxisRef : REFERENCE TO AXIS_REF;
    {attribute 'hide'}
    iMotionLogger : I_MotionLogger := 0;
    {attribute 'hide'}
    iLimSwStatus : I_LimSwStatus;
    fbMcHome : MC_Home;
    fbMcSetPosition : MC_SetPosition;
    fPosition : LREAL;
    fOffset : LREAL;
    {attribute 'hide'}
    nHomeState : UINT;
    //eHomeMode: E_EpicsHomeCmd :=E_EpicsHomeCmd.NONE;
    nHomeMode: INT :=E_EpicsHomeCmd.NONE;
    {attribute 'hide'}
    bForwardLimHitFirst : BOOL;
    {attribute 'hide'}
    bBackwardLimHitFirst : BOOL;
    {attribute 'hide'}
    ftForwardSwHitFirst : F_TRIG;
    {attribute 'hide'}
    ftBackwardLimHitFirst : R_TRIG;
    {attribute 'hide'}
    ftBackwardSwHitFirst: F_TRIG;
    {attribute 'hide'}
    rtHomeSwHitFirst : R_TRIG;
    {attribute 'hide'}
    bHomeSwHitFirst : BOOL;
    {attribute 'hide'}
    bHLDone : BOOL;
    {attribute 'hide'}
    rtDone : R_TRIG;
    {attribute 'hide'}
    bHomeDone: BOOL;
	rtError: R_TRIG;
	bIsLowMode : BOOL;
	bLimitEnable : BOOL;
	eInitSearchDir, eInitSyncDir, eRetrySearchDir, eRetrySyncDir : MC_Direction;
	bLimitHitFirst : BOOL;
	ftLimitHitFirst : F_TRIG; // or a reference if your F_TRIGs are function blocks per direction
	bHomeRequested: BOOL;
	bExecLatched: BOOL;
    bReadyForHome : BOOL;
    bStartHoming  : BOOL;
	eRequestedBufferMode: MC_BufferMode;
	bInterlocksOK: BOOL;
	bEdgeToStart: BOOL;
	bIsLow: BOOL;
	rtHomeRequest: R_TRIG;
	bRisingEdgeReq: BOOL;
	bAborted: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Validate reference
IF NOT __ISVALIDREF(AxisRef) THEN
    RETURN;
END_IF

// Detect the rising edge of a home request only
rtHomeRequest(CLK := bHomeRequested);
bRisingEdgeReq := rtHomeRequest.Q;

// On rising edge, check interlocks and (re)arm bStartHoming if safe
IF bRisingEdgeReq THEN
    bInterlocksOK := 
        iLimSwStatus.LimitBackwardEnable AND
        iLimSwStatus.LimitForwardEnable AND
        NOT iLimSwStatus.LimitHome;
    IF bInterlocksOK THEN
        bStartHoming := TRUE;
        //nHomeState := 0; // always reset substates for a new home request
    ELSE
        bStartHoming := FALSE;
    END_IF
END_IF

// Clear SetPosition execute, unless we just did a home (it will get set as needed)
fbMcSetPosition.Execute := FALSE;

// Prepare all parameters, substates if needed, but DO NOT call fbMcHome here!
CASE nHomeMode OF

    // -------- LOW/HIGH LIMIT (parameterized) ---------------
    E_EpicsHomeCmd.LOW_LIMIT, E_EpicsHomeCmd.HIGH_LIMIT:
        bIsLow := (nHomeMode = E_EpicsHomeCmd.LOW_LIMIT);
        fbMcHome.HomingMode             := MC_HomingMode.MC_DefaultHoming;
        fbMcHome.Options.ClearPositionLag:= TRUE;
        IF bIsLow THEN
            fbMcHome.Options.SearchDirection := MC_Direction.MC_Negative_Direction;
            fbMcHome.Options.SyncDirection   := MC_Direction.MC_Positive_Direction;
            fbMcHome.bCalibrationCam        := NOT iLimSwStatus.LimitBackwardEnable;
        ELSE
            fbMcHome.Options.SearchDirection := MC_Direction.MC_Positive_Direction;
            fbMcHome.Options.SyncDirection   := MC_Direction.MC_Negative_Direction;
            fbMcHome.bCalibrationCam        := NOT iLimSwStatus.LimitForwardEnable;
        END_IF
        // *** Only set execute ONCE (and ONCE ONLY) when MC_Home.Done is true ***
        fbMcSetPosition.Execute := fbMcHome.Done;

    // -------- HOME_VIA_LOW/HIGH (state machine) ----------
    E_EpicsHomeCmd.HOME_VIA_LOW, E_EpicsHomeCmd.HOME_VIA_HIGH:
        bIsLow := (nHomeMode = E_EpicsHomeCmd.HOME_VIA_LOW);
		fbMcHome.HomingMode := MC_HomingMode.MC_DefaultHoming;
		fbMcHome.Options.ClearPositionLag := TRUE;
        IF bIsLow THEN
            bLimitEnable := iLimSwStatus.LimitBackwardEnable;
            eInitSearchDir := MC_Direction.MC_Negative_Direction;
            eInitSyncDir := MC_Direction.MC_Positive_Direction;
            eRetrySearchDir := MC_Direction.MC_Positive_Direction;
            eRetrySyncDir := MC_Direction.MC_Negative_Direction;
            ftLimitHitFirst := ftBackwardSwHitFirst;
        ELSE
            bLimitEnable := iLimSwStatus.LimitForwardEnable;
            eInitSearchDir := MC_Direction.MC_Positive_Direction;
            eInitSyncDir := MC_Direction.MC_Negative_Direction;
            eRetrySearchDir := MC_Direction.MC_Negative_Direction;
            eRetrySyncDir := MC_Direction.MC_Positive_Direction;
            ftLimitHitFirst := ftForwardSwHitFirst;
        END_IF
        fbMcHome.bCalibrationCam := iLimSwStatus.LimitHome OR NOT bLimitEnable;

        CASE nHomeState OF
            0: // Prep initial move toward limit
                fbMcHome.Options.SearchDirection := eInitSearchDir;
                fbMcHome.Options.SyncDirection   := eInitSyncDir;
                IF fbMcHome.Busy THEN nHomeState := 1; END_IF
            1: // Arm triggers for limit/home switch events
                IF bIsLow THEN
                    ftBackwardSwHitFirst(CLK := iLimSwStatus.LimitBackwardEnable);
                ELSE
                    ftForwardSwHitFirst(CLK := iLimSwStatus.LimitForwardEnable);
                END_IF
                rtHomeSwHitFirst(CLK := iLimSwStatus.LimitHome);
                IF fbMcHome.Busy THEN
                    IF rtHomeSwHitFirst.Q THEN
                        bHomeSwHitFirst := TRUE;
                        nHomeState := 4; // home OK -- complete
                    ELSIF ftLimitHitFirst.Q THEN
                        bLimitHitFirst := TRUE;
                        nHomeState := 2; // needs retry
                    END_IF
                END_IF
            2: // Wait for MC_Home complete after hitting limit
                IF bLimitHitFirst AND fbMcHome.Done THEN
                    bHLDone := TRUE;
                    bHomeSwHitFirst := FALSE;
                    bLimitHitFirst := FALSE;
                    nHomeState := 3; // ready for retry move
                END_IF
            3: // Prep retry in opposite direction. DO NOT pulse MC_Home here!
                fbMcHome.Options.SearchDirection := eRetrySearchDir;
                fbMcHome.Options.SyncDirection := eRetrySyncDir;
                fPosition := fbMcHome.Position; // preserve/forward position if needed for MC FB
                bHomeRequested := TRUE; // re-arm the request for next scan (this pulse is handled by edge in logic above)
                bStartHoming := FALSE;  // since we just retried, need edge again next scan
                nHomeState := 4;
            4: // Wait for final MC_Home done, then MC_SetPosition
                IF fbMcHome.Done THEN
                    fbMcSetPosition.Execute := TRUE;
                    nHomeState := 5;
                END_IF
            5:
                // Latch bHomeDone below after MC_Home.Done & MC_SetPosition.Done
                IF fbMcHome.Done AND fbMcSetPosition.Done THEN
                    bHLDone := FALSE;
                    bHomeRequested := FALSE;
                    nHomeState := 6;
                END_IF
        END_CASE

    // -------- ABSOLUTE_SET ---------------
    E_EpicsHomeCmd.ABSOLUTE_SET:
        fbMcHome.HomingMode := MC_HomingMode.MC_Direct;
        fbMcHome.Options.SearchDirection := MC_Direction.MC_Undefined_Direction;
        fbMcHome.Options.SyncDirection   := MC_Direction.MC_Undefined_Direction;
        fbMcHome.Options.ClearPositionLag := TRUE;
		fbMcSetPosition.Execute := fbMcHome.Done;
    // -------- NONE (no-op) ---------------
    E_EpicsHomeCmd.NONE:
        bHomeDone := TRUE;
        bStartHoming := FALSE;
END_CASE

// --- Call MC_Home outside state machines (edge/latch logic applies to ALL states) ---
fbMcHome(
    Execute    := bStartHoming,
    Axis       := AxisRef,
    Position   := fPosition,
    BufferMode := eRequestedBufferMode
);
// (single call per scan: never call inside substates!)
// Always call MC_SetPosition for status maintenance
fbMcSetPosition(
    Axis := AxisRef,
    Mode := 0,
    Position := fPosition
);
// --- Latch 'home done' for all non-NONE modes: both MC FBs must be done ---
IF bAborted THEN
    bHomeDone := TRUE;              // Aborted home overrides
ELSE
    bHomeDone S= fbMcHome.Done AND fbMcSetPosition.Done; // Only when genuinely complete
END_IF

// Clear request as soon as MC_Home actually starts the operation
IF fbMcHome.Busy THEN
    bHomeRequested := FALSE;
END_IF

// --- Error logging ---
rtError(CLK := fbMcHome.Error OR fbMcSetPosition.Error);
IF rtError.Q AND fbMcHome.Error THEN
    iMotionLogger.Logger(
        Message := iMotionLogger.ErrorCodeLookup(fbMcHome.ErrorID),
        Level := E_MotionLogLevel.ERROR,
        Source := 'Home'
    );
ELSIF rtError.Q AND fbMcSetPosition.Error THEN
    iMotionLogger.Logger(
        Message := iMotionLogger.ErrorCodeLookup(fbMcSetPosition.ErrorID),
        Level := E_MotionLogLevel.ERROR,
        Source := 'Home'
    );
END_IF]]></ST>
    </Implementation>
    <Property Name="Aborted" Id="{b3440598-2192-4aa3-bd94-648810782f1d}">
      <Declaration><![CDATA[PROPERTY Aborted : BOOL
]]></Declaration>
      <Get Name="Get" Id="{6a45fc91-d1f8-4045-827a-687d21932173}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Aborted := fbMcHome.CommandAborted;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Active" Id="{4386ac45-3e88-4c79-8d18-81c7e83c1e8e}">
      <Declaration><![CDATA[PROPERTY Active : BOOL
]]></Declaration>
      <Get Name="Get" Id="{bdd5f606-f201-4f1a-9491-5ed9fc2ed98d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Active := fbMcHome.Active;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Busy" Id="{c7e43be2-48b0-438b-8ceb-465d60425bfc}">
      <Declaration><![CDATA[PROPERTY Busy : BOOL
]]></Declaration>
      <Get Name="Get" Id="{cb0740bd-cd32-462e-8d30-3401b18588d5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Busy := fbMcHome.Busy;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="CallAfterInit" Id="{bf0efffc-cb26-4144-93d7-4a53b23636d4}">
      <Declaration><![CDATA[METHOD PUBLIC CallAfterInit
VAR_INPUT
    AxisRef : REFERENCE TO AXIS_REF;
    iMotionLogger : I_MotionLogger;
    iLimSwStatus : I_LimSwStatus;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.AxisRef REF= AxisRef;
THIS^.iMotionLogger := iMotionLogger;
THIS^.iLimSwStatus:= iLimSwStatus;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Done" Id="{a400b97e-6245-4667-8036-7fb53f8ce97f}">
      <Declaration><![CDATA[PROPERTY Done : BOOL
]]></Declaration>
      <Get Name="Get" Id="{aef52b53-9bff-4703-970f-52b560ffba73}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Done := bHomeDone;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Error" Id="{d9029227-7d8c-4426-821a-d46327fbfa6d}">
      <Declaration><![CDATA[PROPERTY Error : BOOL
]]></Declaration>
      <Get Name="Get" Id="{4884c9e1-0ab0-469e-aae8-b83b96b6f583}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Error := fbMcHome.Error;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="ErrorID" Id="{cf64e9b6-c8bf-4aa1-9fa1-b62063c78b03}">
      <Declaration><![CDATA[PROPERTY ErrorID : UDINT
]]></Declaration>
      <Get Name="Get" Id="{e14def51-9c37-4182-ba09-611583cf679e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ErrorID := fbMcHome.ErrorID;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_Init" Id="{36203808-aa8e-419d-b89f-47cad560b581}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
    AxisRef : REFERENCE TO AXIS_REF;
    iMotionLogger : I_MotionLogger;
    iLimSwStatus : I_LimSwStatus;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.AxisRef REF= AxisRef;
THIS^.iMotionLogger := iMotionLogger;
THIS^.iLimSwStatus:= iLimSwStatus;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Home" Id="{bc450e32-fe3c-4fef-961a-7ec21133b561}">
      <Declaration><![CDATA[METHOD  Home : BOOL
VAR_INPUT
    Position        : LREAL  := DEFAULT_HOME_POSITION;
    BufferMode      : MC_BufferMode;
 	HomeMode: INT := E_EpicsHomeCmd.NONE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// 1. Store input parameters for use by run()
THIS^.nHomeMode     := HomeMode;
THIS^.fPosition     := Position;
THIS^.eRequestedBufferMode   := BufferMode;

// 2. Arm the request flag for run(), and release any edge-triggered logic
THIS^.bHomeRequested := TRUE;      // "Arm" request for next scan
THIS^.bStartHoming   := FALSE;     // Ensures Execute edge happens safely in run()

// 3. Optionally, reset state/substates if using a homing substates machine
THIS^.nHomeState := 0;

// 4. Reset both MC_Home and MC_SetPosition (important for latching FBs)
fbMcHome(Execute := FALSE, Axis := THIS^.AxisRef);
fbMcSetPosition(Execute := FALSE, Axis := THIS^.AxisRef, Mode := 0, Position := Position);

// 5. Clear additional latches as needed (retry flags, home-done latch, etc.)
THIS^.bHLDone   := FALSE;
THIS^.bHomeDone   := FALSE;
THIS^.bHomeSwHitFirst := FALSE;
THIS^.bLimitHitFirst  := FALSE;
// Clear abort override for new request
THIS^.bAborted := FALSE;
// 6. Optionally, return or set OUT param if you want immediate feedback
Home := FALSE; // Will become TRUE after completion observed in run()]]></ST>
      </Implementation>
    </Method>
    <Method Name="HomeDone" Id="{7fa00646-640c-402d-86fd-81540e8d03cf}">
      <Declaration><![CDATA[METHOD HomeDone
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcHome(
	Execute := FALSE, 
	Axis := THIS^.AxisRef, 
	Done=>bHomeDone
);]]></ST>
      </Implementation>
    </Method>
    <Property Name="LimHomeDone" Id="{20fb5295-3ffb-4772-9ef6-2e47f50a3f94}">
      <Declaration><![CDATA[PROPERTY LimHomeDone : BOOL
]]></Declaration>
      <Get Name="Get" Id="{db41cbe0-bc47-4b18-a6d4-59eff84f4658}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[LimHomeDone := bHLDone;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Message" Id="{50dd0817-9d23-4b27-bd5b-fe17ea82eb6e}">
      <Declaration><![CDATA[PROPERTY Message : T_MAXSTRING
]]></Declaration>
      <Get Name="Get" Id="{5582f213-525c-49f8-9472-dcc0e7068f61}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Mode" Id="{bacfc68b-674d-49fb-a838-6a7b08d66c8b}">
      <Declaration><![CDATA[PROPERTY Mode : INT
]]></Declaration>
      <Get Name="Get" Id="{018ebc11-483b-4d91-b1ca-54274e9fa554}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Mode := nHomeMode;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{d7a9685a-e050-4fa2-92a8-d25079a18728}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nHomeMode := Mode;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="Offset" Id="{48496da5-ced9-4c7a-88b4-656a32aa685b}">
      <Declaration><![CDATA[PROPERTY Offset : LREAL
]]></Declaration>
      <Set Name="Set" Id="{0ef7a418-62f9-4e76-9f2c-837b987f3900}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[fOffset := Offset;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="Position" Id="{afef80c7-a1a3-4197-a7a0-d9553542477a}">
      <Declaration><![CDATA[PROPERTY Position : LREAL
]]></Declaration>
      <Set Name="Set" Id="{6ac419d4-6add-4703-8089-625e0296877b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[fPosition := Position;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="StopHome" Id="{94593668-05c4-46d6-adce-d009b5cea5a9}">
      <Declaration><![CDATA[METHOD StopHome
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Call this when you detect external halt/reset/request

// 1. Immediately stop MC_Home and MC_SetPosition
fbMcHome(
    Execute := FALSE,
    Axis    := THIS^.AxisRef
);
fbMcSetPosition(
    Execute := FALSE,
    Axis    := THIS^.AxisRef,
    Mode    := 0,
    Position:= THIS^.fPosition
);

// 2. Clear/latch all home execution state
THIS^.bHomeRequested    := FALSE;
THIS^.bExecLatched      := FALSE;
THIS^.bStartHoming      := FALSE;
THIS^.bHomeDone         := FALSE;
THIS^.bAborted          := TRUE;     
THIS^.bHLDone           := FALSE;
THIS^.bHomeSwHitFirst   := FALSE;
THIS^.bLimitHitFirst    := FALSE;

// 3. Reinitialize substates if present
THIS^.nHomeState        := 0;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>