<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionDrive" Id="{60d91316-04e3-4af1-aaa1-6a890af932f7}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'call_after_init'}
FUNCTION_BLOCK FB_MotionDrive IMPLEMENTS I_MotionDrive
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
    {attribute 'hide'}
    iMotionAxis: I_MotionAxis;
    {attribute 'hide'}
    iBrake 				: I_Brake;
    {attribute 'hide'}
    iMotionInterlocks	: I_MotionInterlocks;
    {attribute 'hide'}
    iLimSwStatus : I_LimSwStatus;
    {attribute 'hide'}
    iMotionLogger 		: I_MotionLogger;

//     {attribute 'hide'}
// 	iMotionAxisNC : I_MotionAxisNC := 0;
//     {attribute 'hide'}
// 	iMotionAxisNCDS402 : I_MotionAxisNCDS402:= 0;
//     {attribute 'hide'}
// 	iMotionAxisDS402 : I_MotionAxisDS402 := 0;
//     {attribute 'hide'}
// 	iMotionAxisCommonDS402 : I_MotionAxisCommonDS402 := 0;
//      {attribute 'hide'}
// 	iLimSw : I_LimSwStatus := 0;
//      {attribute 'hide'}
//     iMotionInterlocksLimSw	: I_MotionInterlocks := 0;
    bMotionAxisNC      : BOOL;
    bMotionInterlocks : BOOL;
    bMotionInterlocksLimSw : BOOL;
    bMotionAxisNCDS402      : BOOL;
    bMotionAxisCommonDS402 : BOOL;
    bMotionAxisDS402      : BOOL;

   // EPICS Interface
    stMotionEpicsItf : REFERENCE TO ST_MotionEpicsItf;
    eMoveMode : E_EpicsMotorCmd := E_EpicsMotorCmd.MOVE_ABSOLUTE;
    // Determines when we automatically enable the motor
    {attribute 'hide'}
    eEnableMode: E_StageEnableMode:=E_StageEnableMode.DURING_MOTION;

    (* Shortcut Commands *)
    // Start a move to fPosition with fVelocity
    bMoveCmd: BOOL;
    // Start the homing routine
    {attribute 'pytmc' := '
        pv: PLC:bHomeCmd
        io: io
        field: DESC Start the homing routine
    '}
    bHomeCmd: BOOL;
    // Close or open loop operation ( DS402 Piezo axis )
    {attribute 'pytmc' := '
        pv: PLC:bServo
        io: io
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC Used internally to reset errors
    '}
    bServo : BOOL;

    bHalt : BOOL;
    sName : STRING;
    {attribute 'hide'}
    eMoveState	: E_MoveState;
    {attribute 'hide'}
    bNewMoveReq : BOOL;
    {attribute 'hide'}
    bExecHome 	: BOOL;
    {attribute 'hide'}
    bExecMove 	: BOOL;
    {attribute 'hide'}
    rtMoveCmdShortcut	: R_TRIG;
    {attribute 'hide'}
    rtHomeCmdShortcut 	: R_TRIG;
    {attribute 'hide'}
    rtUserExec 			: R_TRIG;
    {attribute 'hide'}
    rtNewMoveReq 		: R_TRIG;
    {attribute 'hide'}
    rtTarget			: R_TRIG;
    {attribute 'hide'}
    rtHomed				: R_TRIG;
    {attribute 'hide'}
    rtValidExec 	: R_TRIG;
    {attribute 'hide'}
    rtReset 			: R_TRIG;
    {attribute 'hide'}
    ftStopExec 			: F_TRIG;
    {attribute 'hide'}
    ftError 			: F_TRIG;
    {attribute 'hide'}
    nCommandLocal: UINT;
    {attribute 'hide'}
    nCmdDataLocal: UINT;
    {attribute 'hide'}
    ftLocalStart : F_TRIG;
    {attribute 'hide'}
    bInitStart : BOOL;
    {attribute 'hide'}
    bLocalExec : BOOL;
    {attribute 'hide'}
    bEnableDone : BOOL;
    {attribute 'hide'}
    bPrepareDisable : BOOL;
    {attribute 'hide'}
    rtEnableMode : R_TRIG;
    {attribute 'hide'}
    rtStopExec : R_TRIG;
    {attribute 'hide'}
    rtInterlockEvent : R_TRIG;
    {attribute 'hide'}
    bCmdExecute : BOOL;
    {attribute 'hide'}
    bHaltAbort : BOOL;
    {attribute 'hide'}
    ftHaltAbort : F_TRIG;
    {attribute 'hide'}
    rtRestoreDone : R_TRIG;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT __ISVALIDREF( THIS^.stMotionEpicsItf ) THEN
   RETURN;
END_IF

// catch high priority message
// an extended error message from FB_MotionLogger will display cyclic errors and warning
IF iMotionAxis.Error THEN
   stMotionEpicsItf.bError := iMotionAxis.Error;
   stMotionEpicsItf.nErrorId := iMotionAxis.ErrorID;
   stMotionEpicsItf.sErrorMessage := iMotionAxis.Message;
ELSIF iMotionInterlocks.Error THEN
   stMotionEpicsItf.bError := iMotionInterlocks.Error;
   stMotionEpicsItf.nErrorId := iMotionInterlocks.ErrorID;
   stMotionEpicsItf.sErrorMessage := iMotionInterlocks.Message;
// Warnings have lowest priority
ELSIF iMotionInterlocks.Warning THEN
   stMotionEpicsItf.sErrorMessage := iMotionInterlocks.Message;
ELSE
   stMotionEpicsItf.bError := FALSE;
   stMotionEpicsItf.nErrorId := 0;
   stMotionEpicsItf.sErrorMessage := '';
END_IF


THIS^.PreMoveHandling();
// Drive state Machine here
CASE eMoveState OF
   E_MoveState.IDLING:;
       // Delay the disable until axis reach standstill
       // and this state machine is idling
       IF THIS^.bPrepareDisable AND THIS^.iMotionAxis.StandStill THEN
           THIS^.bPrepareDisable := FALSE;
           THIS^.stMotionEpicsItf.bEnable := FALSE;
       ELSIF bExecMove OR bExecHome THEN
           eMoveState := E_MoveState.INIT_MOVE;
       ELSIF stMotionEpicsItf.bError THEN
           eMoveState := E_MoveState.MOVE_ERROR;
       END_IF

   E_MoveState.INIT_MOVE:
       // When we start, set the busy/done appropriately
       stMotionEpicsItf.bBusy := TRUE;
       stMotionEpicsItf.bDone := FALSE;
       // reset error flag
       stMotionEpicsItf.sErrorMessage := '';
       CASE stMotionEpicsItf.nCommand OF
           E_EpicsMotorCmd.MOVE_ABSOLUTE:
               eMoveMode := E_EpicsMotorCmd.MOVE_ABSOLUTE;
               bCmdExecute := bExecMove AND (nCommandLocal=3);
           E_EpicsMotorCmd.HOME:
               eMoveMode := E_EpicsMotorCmd.HOME;
               bCmdExecute := nCommandLocal=10 AND bExecHome;
       END_CASE

       IF bExecMove THEN
            THIS^.iMotionAxis.MoveAbsolute(	Execute:=FALSE,
                       Position:=THIS^.stMotionEpicsItf.fPosition,
                       Velocity := THIS^.stMotionEpicsItf.fVelocity,
                       Acceleration := THIS^.stMotionEpicsItf.fAcceleration,
                       Deceleration := THIS^.stMotionEpicsItf.fDeceleration
                );
            // Activate backlash compensation
            THIS^.iMotionAxis.BacklashCompensationActive(Active:=TRUE, RampVelocity:=THIS^.stMotionEpicsItf.fVelocity/10.0);
       ELSIF bExecHome THEN
            // Deactivate backlash compensation
            THIS^.iMotionAxis.BacklashCompensationActive(Active:=FALSE, RampVelocity:=0.0);
       END_IF
       // configure and start move.
       IF iMotionAxis.StartMove( eMoveMode, bCmdExecute ) THEN
           eMoveState := E_MoveState.MOVE_IN_PROGRESS;
       END_IF

   E_MoveState.START_MOVE:
       IF stMotionEpicsItf.bError THEN
           eMoveState := E_MoveState.MOVE_ERROR;
       // Move Started.
       ELSIF iMotionAxis.Busy THEN
           eMoveState := E_MoveState.MOVE_IN_PROGRESS;
       END_IF

   E_MoveState.MOVE_IN_PROGRESS :

       IF 	stMotionEpicsItf.bError THEN
           eMoveState := E_MoveState.MOVE_ERROR;

       // Move interupted
       ELSIF ftStopExec.Q OR iMotionAxis.Aborted THEN
           eMoveState := E_MoveState.MOVE_INTERRUPTED;

       ELSIF  rtTarget.Q OR rtHomed.Q  THEN
           eMoveState := E_MoveState.TARGET_REACHED;
       END_IF

   E_MoveState.MOVE_INTERRUPTED:

       IF THIS^.iLimSwStatus.LimHitMoving THEN
           eMoveState := E_MoveState.TARGET_REACHED;
       END_IF
       // Wait here for halt or reset done or clearing limit state to be restored
       IF iMotionAxis.AbortDone THEN
           THIS^.ClearVars(Done:=TRUE);
           eMoveState := E_MoveState.IDLING;;
       END_IF

   E_MoveState.TARGET_REACHED:
       THIS^.ClearVars(Done:=TRUE);
       eMoveState := E_MoveState.IDLING;

   E_MoveState.MOVE_ERROR:
       THIS^.ClearVars(Done:=FALSE);
       THIS^.stMotionEpicsItf.bEnable := FALSE;
       IF ftError.Q THEN
           eMoveState := E_MoveState.IDLING;
       END_IF

END_CASE

// Halt is always a user stop but not a limit hit or reset.
THIS^.iMotionAxis.Halt(	Execute:=ftStopExec.Q AND NOT stMotionEpicsItf.bReset AND NOT iLimSwStatus.LimHit
                                             AND (iMotionAxis.MoveAbsoluteBusy AND (nCommandLocal=3))
                                            OR (iMotionAxis.HomeBusy AND (nCommandLocal=10)),
                        Deceleration:=stMotionEpicsItf.fDeceleration);


// Move done, or aborted? prepare disable.
// we'll wait for axis to be in standstill and this state machine to be idling.
THIS^.bPrepareDisable S= (eEnableMode = E_StageEnableMode.DURING_MOTION ) AND THIS^.ftStopExec.Q;

IF THIS^.stMotionEpicsItf.bReset THEN
   // Relese motion cmds
   THIS^.ClearVars(Done:=FALSE);
   THIS^.iMotionAxis.Reset(Execute:= THIS^.stMotionEpicsItf.bReset);
   THIS^.stMotionEpicsItf.bReset := FALSE;
END_IF

// When reset is done axis is standstill
// safe to remove power
IF iMotionAxis.ResetDone THEN
   THIS^.stMotionEpicsItf.bEnable := FALSE;

END_IF

// update EPICS status
THIS^.UpdateParamAndStatus();

// Forward drive commands to interlock blocks
THIS^.iMotionInterlocks.DriveCmd(	Enable:=stMotionEpicsItf.bEnable,
                                    NewMoveReq:=THIS^.bNewMoveReq,
                                    Reset:=iMotionAxis.ResetDone
                                );
// Forward axis state to brake FB
THIS^.iBrake.AxisState := iMotionAxis.AxisState;
    ]]></ST>
    </Implementation>
    <Method Name="ClearVars" Id="{fc3a5981-a4d7-4a2d-bb30-c09c583c9e55}">
      <Declaration><![CDATA[METHOD ClearVars
VAR_INPUT
    Done : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[stMotionEpicsItf.bDone := Done;
stMotionEpicsItf.bBusy := FALSE;
stMotionEpicsItf.bExecute := FALSE;
THIS^.bLocalExec := FALSE;
// release the cmds
THIS^.bHomeCmd:=FALSE;
THIS^.bMoveCmd:=FALSE;
THIS^.binitStart := FALSE;
THIS^.bCmdExecute := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Property Name="EnableMode" Id="{b16f2630-6990-4b39-b9f8-520a45141d0c}">
      <Declaration><![CDATA[{warning 'Add property implementation'}
PROPERTY EnableMode : ENUM_StageEnableMode
]]></Declaration>
      <Get Name="Get" Id="{7a51a46e-96ce-4c74-a79d-9c4933dd0bbb}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[EnableMode := eEnableMode;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{45f0a372-ebc2-415b-8bac-12fafdac995e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[eEnableMode := EnableMode;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="FB_Init" Id="{927f7c72-9006-42d1-8ac3-5d4ce66d6511}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
    stMotionEpicsItf : REFERENCE TO ST_MotionEpicsItf;
    iBrake : I_Brake;
    iMotionInterlocks : I_MotionInterlocks;
    iMotionLogger : I_MotionLogger;
    iMotionAxis: I_MotionAxis;
   // iLimSwStatus : I_LimSwStatus;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.stMotionEpicsItf REF=stMotionEpicsItf;
THIS^.iMotionAxis := iMotionAxis;
THIS^.iMotionLogger:=iMotionLogger;
THIS^.iBrake:=iBrake;
//THIS^.iLimSwStatus:=iLimSwStatus;
THIS^.iMotionInterlocks:=iMotionInterlocks;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Instances" Id="{d9be84d7-fa96-4fa1-bfc2-ca22602705a2}">
      <Declaration><![CDATA[{attribute 'call_after_init'}
METHOD Instances
VAR_INPUT
END_VAR

VAR

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// bMotionAxisNC  := __QUERYINTERFACE(iMotionAxisCommon, iMotionAxisNC) AND NOT __QUERYINTERFACE(iMotionAxisCommon,iMotionAxisCommonDS402);
// bMotionAxisNCDS402  := __QUERYINTERFACE(iMotionAxisCommon,iMotionAxisNCDS402) AND __QUERYINTERFACE(iMotionAxisCommon,iMotionAxisCommonDS402);
// bMotionAxisDS402  := __QUERYINTERFACE(iMotionAxisCommon, iMotionAxisDS402);
// bMotionInterlocks  := __QUERYINTERFACE(iMotionInterlocks,iMotionInterlocks) AND NOT __QUERYINTERFACE(iMotionInterlocks,iLimSw);
// bMotionInterlocksLimSw  := __QUERYINTERFACE(iMotionInterlocks,iMotionInterlocks) AND __QUERYINTERFACE(iMotionInterlocks,iLimSw);;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Name" Id="{0539b87b-757a-4783-8076-20784ec838b8}">
      <Declaration><![CDATA[{warning 'Add property implementation'}
PROPERTY Name : STRING
]]></Declaration>
      <Get Name="Get" Id="{de5a88c8-697f-4c59-899f-a942f6da58ae}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Name := sName;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{b5eeddf9-6a45-438a-aa8f-016a0e45ff45}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sName := Name;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="PreMoveHandling" Id="{b70d40df-94ce-4a86-890c-8d206ac7e676}">
      <Declaration><![CDATA[METHOD PreMoveHandling
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
  Check for the plc shortcut commands
  Used for testing or to circumvent motor record issues
  A request is process and qualified as a legitimate move after it clears interlocks checks
*)
rtMoveCmdShortcut(CLK:=THIS^.bMoveCmd);
rtHomeCmdShortcut(CLK:=THIS^.bHomeCmd);
// Execute on rising edge
IF rtMoveCmdShortcut.Q AND NOT stMotionEpicsItf.bExecute THEN
   stMotionEpicsItf.bExecute:=TRUE;
   stMotionEpicsItf.nCommand:=E_EpicsMotorCmd.MOVE_ABSOLUTE;
   // attempting to move an axis without homing first?
   IF iMotionAxis.HomeMode <> E_EpicsHomeCmd.NONE AND NOT iMotionAxis.HomeDone THEN
       stMotionEpicsItf.sErrorMessage:='Axis homing mode set, but homing routine pending';
   END_IF
ELSIF rtHomeCmdShortcut.Q AND NOT stMotionEpicsItf.bExecute THEN
   stMotionEpicsItf.bExecute:= NOT ( stMotionEpicsItf.nCmdData = E_EpicsHomeCmd.ABSOLUTE_SET ) OR NOT ( stMotionEpicsItf.nCmdData = E_EpicsHomeCmd.NONE);
   stMotionEpicsItf.nCommand:=E_EpicsMotorCmd.HOME;
   // Automatically fill the correct nCmdData for homing
   stMotionEpicsItf.nCmdData:=iMotionAxis.HomeMode;
END_IF

rtUserExec(CLK:=stMotionEpicsItf.bExecute);
bNewMoveReq S= rtUserExec.Q AND NOT iMotionAxis.Busy AND iMotionInterlocks.MoveOk;
// An axis or interlocks error will immediately invalidate this this request.
bNewMoveReq R= NOT stMotionEpicsItf.bExecute OR stMotionEpicsItf.bError;
bPrepareDisable R= bNewMoveReq;
//
rtNewMoveReq(CLK:=bNewMoveReq);
rtEnableMode(CLK:=(eEnableMode = E_StageEnableMode.DURING_MOTION));
// Handle auto-enable timing
CASE eEnableMode OF
   E_StageEnableMode.ALWAYS:
       stMotionEpicsItf.bEnable:=TRUE;
   E_StageEnableMode.DURING_MOTION:
       IF rtEnableMode.Q THEN
           stMotionEpicsItf.bEnable := FALSE;
       END_IF
       // Power interlock only enabled with a new move request
       IF rtNewMoveReq.Q THEN
           stMotionEpicsItf.bEnable S= bNewMoveReq (*iMotionInterlocks.SafetyReady*);
       END_IF
END_CASE
//
// Get a definitive bEnabled reading
THIS^.bEnableDone := iMotionAxis.AxisEnabled();

//
// This is the output interlock check used to allow the requested move
bLocalExec:= stMotionEpicsItf.bExecute AND iMotionInterlocks.PowerEnabled AND THIS^.bEnableDone (*AND iMotionInterlocks.SafetyReady*);

bExecHome:=THIS^.bLocalExec AND stMotionEpicsItf.nCommand = 10;
bExecMove:=THIS^.bLocalExec AND NOT bExecHome;
//
// Transfer nCommand and nCmdData to local copies at rising edge of bExecute
// (avoid issues if nCommand or nCmdData are changed during a command)
rtValidExec(CLK:=(THIS^.bExecMove OR THIS^.bExecHome));
IF rtValidExec.Q THEN
 // used for jog, modulo, GearIn which are not implemented here
 nCmdDataLocal:=INT_TO_UINT(stMotionEpicsItf.nCmdData);
 nCommandLocal:=INT_TO_UINT(stMotionEpicsItf.nCommand);
END_IF
//
// //  Abort while moving if:
// // 1- Reset, 2-Halt/UserStop, 3-Limit hit
rtInterlockEvent(CLK:=iMotionInterlocks.InterlockEvent);
rtReset(CLK:=stMotionEpicsItf.bReset);
IF rtReset.Q OR rtInterlockEvent.Q THEN
   stMotionEpicsItf.bExecute := FALSE;
END_IF

ftError(CLK:=stMotionEpicsItf.bError);
rtTarget(CLK:=(iMotionAxis.Done AND bExecMove));
rtHomed(CLK:=iMotionAxis.Done AND bExecHome);
ftStopExec(CLK:=stMotionEpicsItf.bExecute);

// Both Interlock and limSwStatus can control positive and negative enable
// whichever is not used must set the corresponding flags.
iMotionInterlocks.NewMoveReq := THIS^.bNewMoveReq;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="RestoreSettings" Id="{d72becd9-0474-4aeb-9ec0-8e4cee03f8d2}">
      <Declaration><![CDATA[METHOD RestoreSettings
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// no needed in production since the actualposition is already set on the axis
// and epics status will get that last position
// use this to restore anything thats not an axisref paramter.
rtRestoreDone(CLK:= THIS^.iMotionAxis.RestoreDone);
IF rtRestoreDone.Q THEN
    THIS^.stMotionEpicsItf.fPosition := THIS^.iMotionAxis.SavedPosition;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateParamAndStatus" Id="{bec7d97e-d393-4df3-816c-df000a420230}">
      <Declaration><![CDATA[METHOD UpdateParamAndStatus]]></Declaration>
      <Implementation>
        <ST><![CDATA[
////////////////////////////////////////////////////////////////////
//// Transfer NC parameter status to EPICS
////////////////////////////////////////////////////////////////////
//stMotionEpicsItf.stAxisStatus.bEnable:=iMotionInterlocks.PowerEnabled;
//stMotionEpicsItf.stAxisStatus.bEnabled:=iMotionAxisCommon.IsEnabled;
//stMotionEpicsItf.stAxisStatus.bExecute:=THIS^.bLocalExec;
//stMotionEpicsItf.stAxisStatus.bHomeSensor:=iMotionDriveShareData.LimHome;

//stMotionEpicsItf.stAxisStatus.bLimitBwd:=(iMotionInterlocks.MoveBackwardEnabled AND iLimSwStatus.MoveBackwardEnabled);
//stMotionEpicsItf.stAxisStatus.bLimitFwd:= (iMotionInterlocks.MoveForwardEnabled AND iLimSwStatus.MoveForwardEnabled);
//stMotionEpicsItf.stAxisStatus.fActDiff:=iMotionAxisCommon.MeasuredPositionDiff;
//stMotionEpicsItf.stAxisStatus.fActPosition:=iMotionAxisCommon.MeasuredPosition;
//stMotionEpicsItf.stAxisStatus.fActVelocity:=iMotionAxisCommon.MeasuredVelocity;
//stMotionEpicsItf.stAxisStatus.fOverride:=iMotionAxisCommon.Override;
//stMotionEpicsItf.stAxisStatus.bBusy:=iMotionAxisCommon.MoveBusy;
//stMotionEpicsItf.stAxisStatus.bHomed:=iMotionAxisCommon.HomeDone;
////stMotionEpicsInterface.stAxisStatus.bJogBwd:=bJogBwd;
////stMotionEpicsInterface.stAxisStatus.bJogFwd:=bJogFwd;
//stMotionEpicsItf.stAxisStatus.bReset:=stMotionEpicsItf.bReset;
//stMotionEpicsItf.stAxisStatus.bError:=stMotionEpicsItf.bError;
//stMotionEpicsItf.stAxisStatus.fAcceleration:=stMotionEpicsItf.fAcceleration;
//stMotionEpicsItf.stAxisStatus.fDeceleration:=stMotionEpicsItf.fDeceleration;
//stMotionEpicsItf.stAxisStatus.fPosition:=stMotionEpicsItf.fPosition;
//stMotionEpicsItf.stAxisStatus.fVelocity:=stMotionEpicsItf.fVelocity;
//stMotionEpicsItf.stAxisStatus.nCmdData:=INT_TO_UINT(stMotionEpicsItf.nCmdData);  //Or nCmdDataLocal
//stMotionEpicsItf.stAxisStatus.nCommand:=INT_TO_UINT(stMotionEpicsItf.nCommand);  //Or nCommandLocal
//stMotionEpicsItf.stAxisStatus.nErrorId:=stMotionEpicsItf.nErrorId;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>