<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionDrive" Id="{60d91316-04e3-4af1-aaa1-6a890af932f7}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotionDrive IMPLEMENTS I_MotionDrive
VAR
    stMotionCommand   : REFERENCE TO ST_MotionCommand;
    stMotionStatus    : REFERENCE TO ST_MotionStatus;
    stExMotionStatus  : REFERENCE TO ST_ExtendedMotionStatus;

    iAxis             : I_MotionAxis;         // Underlying axis logic (stepper, servo, simulated, etc.)
    iInterlocks       : I_MotionInterlocks;   // Interlocks interface for safety/hardware limits
    iLogger           : I_MotionLogger;       // Logging interface
    iMoveRequest      : I_MoveRequest;        // Move/home/stop request interface
    iStateMachine     : I_StateMachine;       // State coordination logic interface
    iBrake            : I_Brake;              // Brake interface

    bSaveAxisParams   : BOOL := TRUE;        // If axis parameters should be saved
    fbTimer           : TON;                  // Timer for internal delayed actions, etc.
    
    // Internal signals/state as needed
    bError            : BOOL;
    rtRestoreDone     : R_TRIG;
    nErrorId          : UDINT;
    sErrorMessage     : STRING;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Restore Position Handling and Axis Parameter Save
rtRestoreDone(CLK := THIS^.iAxis.Status.bRestoreDone AND bSaveAxisParams);
IF rtRestoreDone.Q THEN
    THIS^.stMotionCommand.fPosition := THIS^.iAxis.Status.fSavedPosition;
END_IF

// Update Interlocks & Move Request Enable based on axis status and interlocks
iInterlocks.AxisStatus(
    HomeBusy           := iAxis.Status.bHomeBusy,
    PositiveDirection  := iAxis.Status.bPositiveMotionIsEnabled,
    NegativeDirection  := iAxis.Status.bNegativeMotionIsEnabled
);

iMoveRequest.MoveRequest(
    EnableDone := iAxis.AxisEnabled(),
    MoveOk     := iInterlocks.MoveOk
);

// Handle Halt (user stop only, not interlock or reset)
IF stMotionCommand.bHalt THEN
    THIS^.iMoveRequest.StopMoveRequest();
    
    IF iAxis.Status.bHomeBusy THEN
        iAxis.HomeAbortRecovery();
    END_IF

    // Use enum for command codes instead of magic numbers
    IF NOT stMotionCommand.bReset AND iAxis.Status.bBusy AND (
        (iMoveRequest.Status.nCommand = E_EpicsMotorCmd.HOME) OR
        (iMoveRequest.Status.nCommand = E_EpicsMotorCmd.MOVE_ABSOLUTE)
    ) THEN
        iAxis.Halt(Deceleration := stMotionCommand.fDeceleration);        
    END_IF

    stMotionCommand.bHalt := FALSE;
END_IF

// Handle Reset (clears move requests, errors, state machines, axis reset)
IF stMotionCommand.bReset THEN
    iMoveRequest.ClearMoveRequest();
    iMoveRequest.ClearMoveRequestErrors();
    iInterlocks.Reset();
    iStateMachine.Reset();

    IF iAxis.Status.bHomeBusy THEN
        iAxis.HomeAbortRecovery();
    END_IF

    iAxis.Reset();
    stMotionCommand.bReset := FALSE;
END_IF

// Axis Power Control
iAxis.Power(
    Enable           := iInterlocks.PowerEnabled,
    Enable_Positive  := iMoveRequest.Status.bExecHome OR iInterlocks.MoveForwardEnabled,
    Enable_Negative  := iMoveRequest.Status.bExecHome OR iInterlocks.MoveBackwardEnabled,
    Override         := 100.0,
    BufferMode       := MC_Aborting
);

// Interlock Drive Commands
iInterlocks.DriveCommands(
    MoveEnable := iMoveRequest.Status.bEnable,
    NewMoveReq := iMoveRequest.Status.bNewMoveReq
);

// Axis Parameters Handling
iAxis.ReadAxisParams(
    Enable       := TRUE,
    RefreshDelay := T#1S
);

iAxis.SaveAxisParams(
    Enable := bSaveAxisParams
);

// Error and Warning Status Handling (Axis > Interlock Error > Interlock Warning > None)
IF iAxis.Status.bError THEN
    THIS^.bError       := iAxis.Status.bError;
    THIS^.nErrorId     := iAxis.Status.nErrorID;
    THIS^.sErrorMessage:= iAxis.Status.sMessage;
ELSIF iInterlocks.Error THEN
    THIS^.bError       := iInterlocks.Error;
    THIS^.nErrorId     := iInterlocks.ErrorID;
    THIS^.sErrorMessage:= iInterlocks.Message;
ELSIF iInterlocks.Warning THEN
    THIS^.bError       := FALSE;
    THIS^.nErrorId     := 0;
    THIS^.sErrorMessage:= iInterlocks.Message;
ELSE
    THIS^.bError       := FALSE;
    THIS^.nErrorId     := 0;
    THIS^.sErrorMessage:= '';
END_IF

// Propagate Error to MoveRequest and State Machine
iMoveRequest.MoveRequestError(
    Error        := THIS^.bError,
    ErrorId      := THIS^.nErrorId,
    ErrorMessage := THIS^.sErrorMessage
);

iStateMachine.StateMachine(
    Error          := THIS^.bError, 
    InterlockEvent := THIS^.iInterlocks.Warning
);

// Brake and Status Mapping
iBrake.AxisState := iAxis.Status.eAxisState;

// Main Motion Status Structure
stMotionStatus.nMotionAxisID    := iAxis.Status.nAxisId;
stMotionStatus.bEnabled         := iInterlocks.PowerEnabled;
stMotionStatus.bHomeSensor      := iInterlocks.HomeSensor;
stMotionStatus.bLimitBwd        := iInterlocks.MoveBackwardEnabled;
stMotionStatus.bLimitFwd        := iInterlocks.MoveForwardEnabled;
stMotionStatus.fActDiff         := iAxis.Status.fMeasuredPositionDiff;
stMotionStatus.fActPosition     := iAxis.Status.fMeasuredPosition;
stMotionStatus.fActVelocity     := iAxis.Status.fMeasuredVelocity;
stMotionStatus.fOverride        := iAxis.Status.fPowerOverride;
stMotionStatus.bBusy            := iAxis.Status.bBusy;
stMotionStatus.bHomed           := iAxis.Status.bHomeDone;
stMotionStatus.bWarning         := iInterlocks.Warning;
stMotionStatus.bError           := THIS^.bError;
stMotionStatus.nErrorId         := THIS^.nErrorId;
stMotionStatus.sErrorMessage    := THIS^.sErrorMessage;

// Extended Motion Status (Debug, Testing)
stExMotionStatus.bMotionAxisError        := iAxis.Status.bError;
stExMotionStatus.nMotionAxisErrorId      := iAxis.Status.nErrorID;
stExMotionStatus.bInterlocksError        := iInterlocks.Error;
stExMotionStatus.nInterlocksError        := iInterlocks.ErrorID;
stExMotionStatus.eDriveState             := iStateMachine.MoveState;
stExMotionStatus.bAbortDone              := iAxis.Status.bAbortDone;
stExMotionStatus.bAborted                := iAxis.Status.bAborted;
stExMotionStatus.bLimHomeDone            := iAxis.Status.bLimHomeDone;
stExMotionStatus.bDriveWatchDogStatus    := iStateMachine.WatchDogStatus;
stExMotionStatus.bNewMoveReq             := iMoveRequest.Status.bNewMoveReq;
stExMotionStatus.bEnable                 := iMoveRequest.Status.bEnable;
stExMotionStatus.bIdling                 := iStateMachine.Idling;
stExMotionStatus.bExecute                := iMoveRequest.Status.bExecute;]]></ST>
    </Implementation>
    <Method Name="CallAfterInit" Id="{f39ddf47-4815-43e7-8049-e534fb9f6092}">
      <Declaration><![CDATA[METHOD PUBLIC CallAfterInit
VAR_INPUT
	stMotionCommand : REFERENCE TO ST_MotionCommand;
    stMotionStatus: REFERENCE TO ST_MotionStatus;
	stExMotionStatus : REFERENCE TO ST_ExtendedMotionStatus;
    iInterlocks : I_MotionInterlocks;
    iLogger : I_MotionLogger;
    iAxis: I_MotionAxis;
    iMoveRequest : I_MoveRequest;
    iStateMachine : I_StateMachine;
    iBrake : I_Brake;;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iAxis := iAxis;
THIS^.iLogger:=iLogger;
THIS^.iBrake:=iBrake;
THIS^.iInterlocks:=iInterlocks;
THIS^.iMoveRequest :=iMoveRequest;
THIS^.iStateMachine := iStateMachine;
THIS^.stMotionCommand REF= stMotionCommand;
THIS^.stMotionStatus REF= stMotionStatus;
THIS^.stExMotionStatus REF= stExMotionStatus;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_Init" Id="{927f7c72-9006-42d1-8ac3-5d4ce66d6511}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)

	stMotionCommand : REFERENCE TO ST_MotionCommand;
    stMotionStatus: REFERENCE TO ST_MotionStatus;
	stExMotionStatus : REFERENCE TO ST_ExtendedMotionStatus;
    iInterlocks : I_MotionInterlocks;
    iLogger : I_MotionLogger;
    iAxis: I_MotionAxis;
    iMoveRequest : I_MoveRequest;
    iStateMachine : I_StateMachine;
    iBrake : I_Brake;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iAxis := iAxis;
THIS^.iLogger:=iLogger;
THIS^.iBrake:=iBrake;
THIS^.iInterlocks:=iInterlocks;
THIS^.iMoveRequest :=iMoveRequest;
THIS^.iStateMachine := iStateMachine;
THIS^.stMotionCommand REF= stMotionCommand;
THIS^.stMotionStatus REF= stMotionStatus;
THIS^.stExMotionStatus REF= stExMotionStatus;
]]></ST>
      </Implementation>
    </Method>
    <Property Name="SaveAxisParams" Id="{675b9210-4962-40da-b2b1-5e02c4594be0}">
      <Declaration><![CDATA[PROPERTY SaveAxisParams : BOOL
]]></Declaration>
      <Set Name="Set" Id="{fcfaac2a-4837-40a7-b0f8-034d4107a330}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[bSaveAxisParams := SaveAxisParams;]]></ST>
        </Implementation>
      </Set>
    </Property>
  </POU>
</TcPlcObject>