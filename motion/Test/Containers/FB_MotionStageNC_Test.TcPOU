<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionStageNC_Test" Id="{43fc959c-4f0c-48e3-9ba7-5e5e5850d492}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK INTERNAL FB_MotionStageNC_Test EXTENDS FB_TestSuite
VAR
    fbMotionLogger : ARRAY[1..17] OF FB_MotionLogger;
    fbPersistentDataStorage :  ARRAY[1..17] OF FB_PersistentDataStorage;
 	fbAxisRef :   ARRAY[1..17] OF AXIS_REF;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[GivenMoveCmdAndMoveOkIfResetThenAbortMove_Test1();
GivenMoveCmdAndMoveOkIfHaltThenAbortMove_Test2();
GivenMoveCmdAndMoveOkMoveToTarget1ThenTarget2_Test3();
GivenMoveCmdAndValidInterlocksThenMoveToTarget_Test4();
GivenMoveCmdValidInterlockAndWrongMotionParamsThenGotoErrorStateIfResetThenGotoInitState_Test5();
GivenMoveCmdAndMoveOkAndPositiveBacklashEnabledThenMoveToTargetWithCompensation_Test6();
GivenMoveCmdAndMoveOkAndNegativeBacklashEnabledThenMoveToTargetWithCompensation_Test7();
GivenHomeCmdAndAbsoluteSetAndMoveOkThenMoveToUserDefinedHomePosition_Test8();
GivenHomeCmdNoneAndMoveOkThenSetHomeFlag_Test9();
GivenHomeCmdLowLimitModeBackwardSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test10();
GivenHomeCmdHighLimitModeForwardSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test11();
GivenHomeCmdHomeViaLowModeHomeSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test12();
GivenHomeCmdHomeViaHighModeHomeSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test13();
GivenHomeCmdHomeViaHighModeForwardSwPulseBeforeHomeSwPulseThenMoveToUserDefinePosition_Test14();
GivenHomeCmdHomeViaLowModeBackwardSwPulseBeforeHomeSwPulseThenMoveToUserDefinePosition_Test15();
GivenHomeCmdLowLimitModeAndResetThenAbortHoming_Test16();
OverallStageFeaturesAndOperationalTests_Test17();]]></ST>
    </Implementation>
    <Method Name="GivenHomeCmdAndAbsoluteSetAndMoveOkThenMoveToUserDefinedHomePosition_Test8" Id="{253b6d82-c379-45a7-8590-f79f84a467f7}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdAndAbsoluteSetAndMoveOkThenMoveToUserDefinedHomePosition_Test8
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test8',
                                        AxisRef := fbAxisRef[8],
                                        iMotionLogger := fbMotionLogger[8],
                                        iPersistentDataStorage := fbPersistentDataStorage[8]
                                    ) :=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());


CASE nTestStep OF
    0:
			// Enable safety interlocks and hardware limits
        fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
		nTestStep := 1;
	1:
		fbMotionStage.Home(HomePosition:=20.0, HomeMode:=E_EPicsHomeCmd.ABSOLUTE_SET);
		nTestStep := 2;
	2:
		IF fbMotionStage.stMotionStatus.bDone THEN
			AssertTrue(Condition :=(fbMotionStage.stMotionCommand.fHomePosition - fbAxisRef[8].NcToPlc.ActPos) = 0, Message := 'Hone position not set #1');
			nTestStep := 3;
		END_IF	
END_CASE

fbTestTimer();
fbMotionStage();

IF nTestStep = 3 THEN

TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdHighLimitModeForwardSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test11" Id="{2af3aa63-2d5e-48a5-9af6-8662bf6f8644}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdHighLimitModeForwardSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test11
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test11',
                                        AxisRef := fbAxisRef[11],
                                        iMotionLogger := fbMotionLogger[11],
                                        iPersistentDataStorage := fbPersistentDataStorage[11]
                                    ) :=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: // Enable all interlocks/limits to be ready for homing
        fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;

    1: // Issue home command (to low limit)
        fbMotionStage.Home(HomePosition := 20.0, HomeMode := E_EpicsHomeCmd.HIGH_LIMIT);
        nTestStep := 2;

    2: // Simulate limit switch drop/restore with cam switch events
        IF fbCamSwitchPulserSearch.Q THEN
			// simulate limit release
			fbMotionStage.EnableLimits(
				BackwardEnable:=TRUE, 
				ForwardEnable:=FALSE,
				HomeEnable:=FALSE
			);
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 3;
        END_IF

    3: // Restore limit after cam event
        IF fbCamSwitchPulserSync.Q THEN
			fbMotionStage.EnableLimits(
				BackwardEnable:=TRUE, 
				ForwardEnable:=TRUE,
				HomeEnable:=FALSE
			);
            nTestStep := 4;
        END_IF

    4: // Wait for home sequence completion
        IF fbMotionStage.stMotionStatus.bDone THEN
            nTestStep := 5;
        END_IF
END_CASE

fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();
fbMotionStage();

IF nTestStep = 5 THEN
    AssertTrue(
        Condition := fbAxisRef[11].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fbMotionStage.stMotionCommand.fHomePosition,
        Actual := fbAxisRef[11].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdHomeViaHighModeForwardSwPulseBeforeHomeSwPulseThenMoveToUserDefinePosition_Test14" Id="{bef29b72-04d6-4825-b7ae-27502091b8b5}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdHomeViaHighModeForwardSwPulseBeforeHomeSwPulseThenMoveToUserDefinePosition_Test14
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test14',
                                        AxisRef := fbAxisRef[14],
                                        iMotionLogger := fbMotionLogger[14],
                                        iPersistentDataStorage := fbPersistentDataStorage[14]
                                    ) :=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: // Enable all interlocks/limits for initial homing (home switch not active yet!)
        fbMotionStage.EnableLimits(
            BackwardEnable := TRUE, 
            ForwardEnable  := TRUE,
            HomeEnable     := FALSE
        );
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;

    1: // Issue homing command (via high limit, should travel to positive end first)
        fbMotionStage.Home(
            HomePosition := 5.0,
            HomeMode := E_EpicsHomeCmd.HOME_VIA_HIGH
        );
        nTestStep := 2;

    2: // Simulate forward limit drop
        IF fbCamSwitchPulserSearch.Q THEN
            fbMotionStage.EnableLimits(
                BackwardEnable := TRUE, 
                ForwardEnable  := FALSE,
                HomeEnable     := FALSE
            );
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 3;
        END_IF

    3: // Restore forward limit after event
        IF fbCamSwitchPulserSync.Q THEN
            fbMotionStage.EnableLimits(
                BackwardEnable := TRUE, 
                ForwardEnable  := TRUE,
                HomeEnable     := FALSE
            );
            fbCamSwitchPulserSync.IN := FALSE;
            nTestStep := 4;
        END_IF

    4: // Wait for "first stage" (positive limit) homing done (i.e. LimHomeDone signals)
        IF fbMotionStage.stExMotionStatus.bLimHomeDone THEN
            // prepare for home switch pulse
            fbCamSwitchPulserSearch.IN := TRUE;
            fbCamSwitchPulserSync.IN := FALSE;
            nTestStep := 5;
        END_IF

    5: // Simulate home switch engagement (simulate HomeEnable = TRUE)
        IF fbCamSwitchPulserSearch.Q THEN
            fbMotionStage.EnableLimits(
                BackwardEnable := TRUE, 
                ForwardEnable  := TRUE,
                HomeEnable     := TRUE
            );
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 6;
        END_IF

    6: // Simulate home switch disengagement (return HomeEnable to FALSE)
        IF fbCamSwitchPulserSync.Q THEN
            fbMotionStage.EnableLimits(
                BackwardEnable := TRUE, 
                ForwardEnable  := TRUE,
                HomeEnable     := FALSE
            );
            fbCamSwitchPulserSync.IN := FALSE;
            nTestStep := 7;
        END_IF 

    7: // Wait for overall homing to complete (done)
        IF fbMotionStage.stMotionStatus.bDone THEN
            nTestStep := 8;
        END_IF
END_CASE

// Cyclic calls required for timer and cam events and motion stage
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();
fbMotionStage();

IF nTestStep = 8 THEN
    AssertTrue(
        Condition := fbAxisRef[14].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fbMotionStage.stMotionCommand.fHomePosition,
        Actual := fbAxisRef[14].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdHomeViaHighModeHomeSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test13" Id="{501bb430-c4c8-4962-b9b7-05487279548f}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdHomeViaHighModeHomeSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test13
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test13',
                                        AxisRef := fbAxisRef[13],
                                        iMotionLogger := fbMotionLogger[13],
                                        iPersistentDataStorage := fbPersistentDataStorage[13]
                                    ):=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: // Enable all interlocks/limits to be ready for homing
		fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;

    1: // Issue home command (to low limit)
        fbMotionStage.Home(HomePosition := 20.0, HomeMode := E_EpicsHomeCmd.HOME_VIA_HIGH);
        nTestStep := 2;

    2: // Simulate limit switch drop/restore with cam switch events
        IF fbCamSwitchPulserSearch.Q THEN
			fbMotionStage.EnableLimits(
				BackwardEnable:=TRUE, 
				ForwardEnable:=TRUE,
				HomeEnable:=TRUE
			);
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 3;
        END_IF

    3: // Restore limit after cam event
        IF fbCamSwitchPulserSync.Q THEN
			fbMotionStage.EnableLimits(
				BackwardEnable:=TRUE, 
				ForwardEnable:=TRUE,
				HomeEnable:=FALSE
			);
            nTestStep := 4;
        END_IF

    4: // Wait for home sequence completion
        IF fbMotionStage.stMotionStatus.bDone THEN
            nTestStep := 5;
        END_IF
END_CASE

fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();
fbMotionStage();

IF nTestStep = 5 THEN
    AssertTrue(
        Condition := fbAxisRef[13].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fbMotionStage.stMotionCommand.fHomePosition,
        Actual := fbAxisRef[13].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdHomeViaLowModeBackwardSwPulseBeforeHomeSwPulseThenMoveToUserDefinePosition_Test15" Id="{f5542e4e-2910-481a-85ce-1a7f0cb0b943}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdHomeViaLowModeBackwardSwPulseBeforeHomeSwPulseThenMoveToUserDefinePosition_Test15
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test15',
                                        AxisRef := fbAxisRef[15],
                                        iMotionLogger := fbMotionLogger[15],
                                        iPersistentDataStorage := fbPersistentDataStorage[15]
                                    ) :=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: // Enable all interlocks/limits for initial homing (home switch not active yet!)
        fbMotionStage.EnableLimits(
            BackwardEnable := TRUE, 
            ForwardEnable  := TRUE,
            HomeEnable     := FALSE
        );
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;

    1: // Issue homing command (via high limit, should travel to positive end first)
        fbMotionStage.Home(
            HomePosition := 5.0,
            HomeMode := E_EpicsHomeCmd.HOME_VIA_LOW
        );
        nTestStep := 2;

    2: // Simulate forward limit drop
        IF fbCamSwitchPulserSearch.Q THEN
            fbMotionStage.EnableLimits(
                BackwardEnable := FALSE, 
                ForwardEnable  := TRUE,
                HomeEnable     := FALSE
            );
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 3;
        END_IF

    3: // Restore forward limit after event
        IF fbCamSwitchPulserSync.Q THEN
            fbMotionStage.EnableLimits(
                BackwardEnable := TRUE, 
                ForwardEnable  := TRUE,
                HomeEnable     := FALSE
            );
            fbCamSwitchPulserSync.IN := FALSE;
            nTestStep := 4;
        END_IF

    4: // Wait for "first stage" (positive limit) homing done (i.e. LimHomeDone signals)
        IF fbMotionStage.stExMotionStatus.bLimHomeDone THEN
            // prepare for home switch pulse
            fbCamSwitchPulserSearch.IN := TRUE;
            fbCamSwitchPulserSync.IN := FALSE;
            nTestStep := 5;
        END_IF

    5: // Simulate home switch engagement (simulate HomeEnable = TRUE)
        IF fbCamSwitchPulserSearch.Q THEN
            fbMotionStage.EnableLimits(
                BackwardEnable := TRUE, 
                ForwardEnable  := TRUE,
                HomeEnable     := TRUE
            );
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 6;
        END_IF

    6: // Simulate home switch disengagement (return HomeEnable to FALSE)
        IF fbCamSwitchPulserSync.Q THEN
            fbMotionStage.EnableLimits(
                BackwardEnable := TRUE, 
                ForwardEnable  := TRUE,
                HomeEnable     := FALSE
            );
            fbCamSwitchPulserSync.IN := FALSE;
            nTestStep := 7;
        END_IF 

    7: // Wait for overall homing to complete (done)
        IF fbMotionStage.stMotionStatus.bDone THEN
            nTestStep := 8;
        END_IF
END_CASE

// Cyclic calls required for timer and cam events and motion stage
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();
fbMotionStage();

IF nTestStep = 8 THEN
    AssertTrue(
        Condition := fbAxisRef[15].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fbMotionStage.stMotionCommand.fHomePosition,
        Actual := fbAxisRef[15].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdHomeViaLowModeHomeSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test12" Id="{0f21ff56-ff7d-42d6-8a7e-507573fd24aa}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdHomeViaLowModeHomeSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test12
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test12',
                                        AxisRef := fbAxisRef[12],
                                        iMotionLogger := fbMotionLogger[12],
                                        iPersistentDataStorage := fbPersistentDataStorage[12]
                                    ) :=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: // Enable all interlocks/limits to be ready for homing
		fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;

    1: // Issue home command (to low limit)
        fbMotionStage.Home(HomePosition := 20.0, HomeMode := E_EpicsHomeCmd.HOME_VIA_LOW);
        nTestStep := 2;

    2: // Simulate limit switch drop/restore with cam switch events
        IF fbCamSwitchPulserSearch.Q THEN
			fbMotionStage.EnableLimits(
				BackwardEnable:=TRUE, 
				ForwardEnable:=TRUE,
				HomeEnable:=TRUE
			);
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 3;
        END_IF

    3: // Restore limit after cam event
        IF fbCamSwitchPulserSync.Q THEN
			fbMotionStage.EnableLimits(
				BackwardEnable:=TRUE, 
				ForwardEnable:=TRUE,
				HomeEnable:=FALSE
			);
            nTestStep := 4;
        END_IF

    4: // Wait for home sequence completion
        IF fbMotionStage.stMotionStatus.bDone THEN
            nTestStep := 5;
        END_IF
END_CASE

fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();
fbMotionStage();

IF nTestStep = 5 THEN
    AssertTrue(
        Condition := fbAxisRef[12].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fbMotionStage.stMotionCommand.fHomePosition,
        Actual := fbAxisRef[12].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdLowLimitModeAndResetThenAbortHoming_Test16" Id="{fb1ff3e0-5234-4117-b553-a90d648343f0}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdLowLimitModeAndResetThenAbortHoming_Test16
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test16',
                                        AxisRef := fbAxisRef[16],
                                        iMotionLogger := fbMotionLogger[16],
                                        iPersistentDataStorage := fbPersistentDataStorage[16]
                                    ):=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#3S);
    fbResetTimer: TON := (IN:=TRUE, PT:=T#500MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());


CASE nTestStep OF
    0: // Enable all interlocks/limits for initial homing (home switch not active yet!)
        fbMotionStage.EnableLimits(
            BackwardEnable := TRUE, 
            ForwardEnable  := TRUE,
            HomeEnable     := FALSE
        );
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;

    1: // Issue homing command (via high limit, should travel to positive end first)
        fbMotionStage.Home(
            HomePosition := 5.0,
            HomeMode := E_EpicsHomeCmd.LOW_LIMIT
        );
        nTestStep := 2;
    2:
        IF fbResetTimer.Q THEN
            fbMotionStage.Reset();
            fbResetTimer.IN := FALSE;
            nTestStep := 3;
        END_IF
    3:
		// resetting a homing sequence will set mc_home into error state
        IF fbMotionStage.stMotionStatus.bDone THEN
            nTestStep := 4;
        END_IF
END_CASE

fbResetTimer();
fbTestTimer();
fbMotionStage();

IF nTestStep = 4 THEN
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );

    TEST_FINISHED();
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdLowLimitModeBackwardSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test10" Id="{38063202-adc8-4d3e-8e4a-d284a88ae9ab}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdLowLimitModeBackwardSwPulseMoveOkThenMoveToUserDefinedHomePosition_Test10
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test10',
                                        AxisRef := fbAxisRef[10],
                                        iMotionLogger := fbMotionLogger[10],
                                        iPersistentDataStorage := fbPersistentDataStorage[10]
                                    ):=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: // Enable all interlocks/limits to be ready for homing
        fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;

    1: // Issue home command (to low limit)
        fbMotionStage.Home(HomePosition := 20.0, HomeMode := E_EpicsHomeCmd.LOW_LIMIT);
        nTestStep := 2;

    2: // Simulate limit switch drop/restore with cam switch events
		// simulate limit release
        IF fbCamSwitchPulserSearch.Q THEN
			fbMotionStage.EnableLimits(
				BackwardEnable:=FALSE, 
				ForwardEnable:=TRUE,
				HomeEnable:=FALSE
			);
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 3;
        END_IF

    3: // Restore limit after cam event
        IF fbCamSwitchPulserSync.Q THEN
			fbMotionStage.EnableLimits(
				BackwardEnable:=TRUE, 
				ForwardEnable:=TRUE,
				HomeEnable:=FALSE
			);
            nTestStep := 4;
        END_IF

    4: // Wait for home sequence completion
        IF fbMotionStage.stMotionStatus.bDone THEN
            nTestStep := 5;
        END_IF
END_CASE

fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();
fbMotionStage();

IF nTestStep = 5 THEN
    AssertTrue(
        Condition := fbAxisRef[10].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fbMotionStage.stMotionCommand.fHomePosition,
        Actual := fbAxisRef[10].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdNoneAndMoveOkThenSetHomeFlag_Test9" Id="{d4ce9a28-0d09-43a0-9439-db832b2656b8}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdNoneAndMoveOkThenSetHomeFlag_Test9
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test9',
                                        AxisRef := fbAxisRef[9],
                                        iMotionLogger := fbMotionLogger[9],
                                        iPersistentDataStorage := fbPersistentDataStorage[9]
                                    ):=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#3S);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());


CASE nTestStep OF
    0:
		// Enable safety interlocks and hardware limits
        fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
		nTestStep := 1;
	1:
		fbMotionStage.Home(HomePosition:=20.0, HomeMode:=E_EPicsHomeCmd.NONE);
		nTestStep := 2;
	2:
		IF fbMotionStage.stMotionStatus.bHomed THEN
			nTestStep := 3;
		END_IF	
END_CASE

fbTestTimer();
fbMotionStage();

IF nTestStep = 3 THEN

TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdAndMoveOkAndNegativeBacklashEnabledThenMoveToTargetWithCompensation_Test7" Id="{2b0e18de-bb60-4f66-8435-2821190f306d}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdAndMoveOkAndNegativeBacklashEnabledThenMoveToTargetWithCompensation_Test7
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test7',
                                        AxisRef := fbAxisRef[7],
                                        iMotionLogger := fbMotionLogger[7],
                                        iPersistentDataStorage := fbPersistentDataStorage[7]
                                    ):=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: // Enable safety and backlash compensation
         fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
		fbMotionStage.EnableBacklashCompensation(UserEnable := TRUE, Compensation := -2.5);
        nTestStep := 1;
    1: // Forward move, should have **no** compensation applied
        fbMotionStage.AbsoluteMoveWithBacklashCompensation(
            Position := -10.0,
            Velocity := 200.0,
            Acceleration := 400.0,
            Deceleration := 400.0
        );
        nTestStep := 2;
    2:
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(-10.0 - fbAxisRef[7].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #1'
            );
            AssertTrue(
                Condition := (fbAxisRef[7].NcToPlc.ActPos - fbAxisRef[7].NcToPlc.ActPosWithoutPosCorrection) = 0,
                Message := 'No compensation in this direction #2'
            );
            nTestStep := 3;
        END_IF
    3: // Reverse move, should have 2.5 compensation
        fbMotionStage.AbsoluteMoveWithBacklashCompensation(
            Position := 80.0,
            Velocity := 200.0,
            Acceleration := 400.0,
            Deceleration := 400.0
        );
        nTestStep := 4;
    4:
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(80.0 - fbAxisRef[7].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #3'
            );
            AssertTrue(
                Condition := (fbAxisRef[7].NcToPlc.ActPos - fbAxisRef[7].NcToPlc.ActPosWithoutPosCorrection) = 2.5,
                Message := 'This move must have a 2.5 compensation #4'
            );
            nTestStep := 5;
        END_IF
    5: // Compensation now 0, move uncompensated
        fbMotionStage.EnableBacklashCompensation(UserEnable := TRUE, Compensation := 0);
        nTestStep := 6;
    6:
        fbMotionStage.AbsoluteMoveWithBacklashCompensation(
            Position := 120.0,
            Velocity := 200.0,
            Acceleration := 400.0,
            Deceleration := 400.0
        );
        nTestStep := 7;
    7:
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(120.0 - fbAxisRef[7].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #5'
            );
            AssertTrue(
                Condition := (fbAxisRef[7].NcToPlc.ActPos - fbAxisRef[7].NcToPlc.ActPosWithoutPosCorrection) = 0,
                Message := 'Actual compensation must be 0 #6'
            );
            nTestStep := 8;
        END_IF
    8: // Set -3.5 for next, expect 3.5 compensation in reverse
        fbMotionStage.EnableBacklashCompensation(UserEnable := TRUE, Compensation := -3.5);
        nTestStep := 9;
    9:
        fbMotionStage.AbsoluteMove(
            Position := 160.0,
            Velocity := 200.0,
            Acceleration := 400.0,
            Deceleration := 400.0
        );
        nTestStep := 10;
    10:
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(160.0 - fbAxisRef[7].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #7'
            );
            AssertTrue(
                Condition := (fbAxisRef[7].NcToPlc.ActPos - fbAxisRef[7].NcToPlc.ActPosWithoutPosCorrection) = 3.5,
                Message := 'This move must have a 3.5 compensation #8'
            );
            nTestStep := 11;
        END_IF
    11: // Disable compensation, next should be uncompensated
        fbMotionStage.EnableBacklashCompensation(UserEnable := FALSE, Compensation := -3.5);
        nTestStep := 12;
    12:
        fbMotionStage.AbsoluteMove(
            Position := 180.0,
            Velocity := 200.0,
            Acceleration := 400.0,
            Deceleration := 400.0
        );
        nTestStep := 13;
    13:
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(180.0 - fbAxisRef[7].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #9'
            );
            AssertTrue(
                Condition := (fbAxisRef[7].NcToPlc.ActPos - fbAxisRef[7].NcToPlc.ActPosWithoutPosCorrection) = 0,
                Message := 'This move is not compensated #10'
            );
            nTestStep := 14;
        END_IF
END_CASE

fbTestTimer();
fbMotionStage();

IF nTestStep = 14 THEN
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdAndMoveOkAndPositiveBacklashEnabledThenMoveToTargetWithCompensation_Test6" Id="{eacd47ff-5090-4d4e-8c56-5ace2594f75c}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdAndMoveOkAndPositiveBacklashEnabledThenMoveToTargetWithCompensation_Test6
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test6',
                                        AxisRef := fbAxisRef[6],
                                        iMotionLogger := fbMotionLogger[6],
                                        iPersistentDataStorage := fbPersistentDataStorage[6]
                                    ) :=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: 
		//Enable safety interlocks AND hardware limits
         fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
		// disable restore saved position
        fbMotionStage.EnableInterlocks();
		//Enable 2.5 backlash compensation
        fbMotionStage.EnableBacklashCompensation(UserEnable := TRUE, Compensation := 2.5);
        nTestStep := 1;
    1: // Forward move, should have **no** compensation applied
        fbMotionStage.AbsoluteMoveWithBacklashCompensation(
            Position := 100.0,
            Velocity := 50.0,
            Acceleration := 500.0,
            Deceleration := 500.0
        );
        nTestStep := 2;
    2: // Wait for move done, check result
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(fbMotionStage.MotionCmd.fPosition - fbAxisRef[6].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #1'
            );
            AssertTrue(
                Condition := (fbAxisRef[6].NcToPlc.ActPos - fbAxisRef[6].NcToPlc.ActPosWithoutPosCorrection) = 0,
                Message := 'No compensation in this direction #2'
            );
            nTestStep := 3;
        END_IF
    3: // Reverse move, should have 2.5 compensation applied
        IF fbMotionStage.ExMotionStatus.bIdling THEN
            fbMotionStage.AbsoluteMoveWithBacklashCompensation(
                Position := 50.0,
                Velocity := 50.0,
                Acceleration := 500.0,
                Deceleration := 500.0
            );
            nTestStep := 4;
        END_IF
    4:
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(fbMotionStage.MotionCmd.fPosition - fbAxisRef[6].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #3'
            );
            AssertTrue(
                Condition := ((fbAxisRef[6].NcToPlc.ActPos - fbAxisRef[6].NcToPlc.ActPosWithoutPosCorrection)- 2.5) < 0.001,
                Message := 'This move must have a 2.5 compensation #4'
            );
            nTestStep := 5;
        END_IF
    5: // Set compensation to 0, next move should be uncompensated
        fbMotionStage.EnableBacklashCompensation(UserEnable := TRUE, Compensation := 0);
        nTestStep := 6;
    6:
        fbMotionStage.AbsoluteMoveWithBacklashCompensation(
            Position := 60.0,
            Velocity := 50.0,
            Acceleration := 200.0,
            Deceleration := 200.0
        );
        nTestStep := 7;
    7:
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(60.0 - fbAxisRef[6].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #5'
            );
            AssertTrue(
                Condition := (fbAxisRef[6].NcToPlc.ActPos - fbAxisRef[6].NcToPlc.ActPosWithoutPosCorrection) = 0,
                Message := 'Actual compensation must be 0 #6'
            );
            nTestStep := 8;
        END_IF
    8: // Set comp to 3.5 for next move
        fbMotionStage.EnableBacklashCompensation(UserEnable := TRUE, Compensation := 3.5);
        nTestStep := 9;
    9:
        fbMotionStage.AbsoluteMoveWithBacklashCompensation(
            Position := 40.0,
            Velocity := 50.0,
            Acceleration := 200.0,
            Deceleration := 200.0
        );
        nTestStep := 10;
    10:
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(40.0 - fbAxisRef[6].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #7'
            );
            AssertTrue(
                Condition := ((fbAxisRef[6].NcToPlc.ActPos - fbAxisRef[6].NcToPlc.ActPosWithoutPosCorrection)- 3.5) < 0.001,
                Message := 'This move must have a 3.5 compensation #8'
            );
            nTestStep := 11;
        END_IF
    11: // Disable compensation, next move should show 0 compensation
        fbMotionStage.EnableBacklashCompensation(UserEnable := FALSE, Compensation := 0.5);
        nTestStep := 12;
    12:
        fbMotionStage.AbsoluteMoveWithBacklashCompensation(
            Position := 20.0,
            Velocity := 50.0,
            Acceleration := 200.0,
            Deceleration := 200.0
        );
        nTestStep := 13;
    13:
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(20.0 - fbAxisRef[6].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #9'
            );
            AssertTrue(
                Condition := (fbAxisRef[6].NcToPlc.ActPos - fbAxisRef[6].NcToPlc.ActPosWithoutPosCorrection) = 0,
                Message := 'This move is not compensated #10'
            );
            nTestStep := 14;
        END_IF
END_CASE

fbTestTimer();
fbMotionStage();

IF nTestStep = 14 THEN
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdAndMoveOkIfHaltThenAbortMove_Test2" Id="{8f4d1144-cd7b-4793-a403-1f7069d03b65}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdAndMoveOkIfHaltThenAbortMove_Test2
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test2',
                                        AxisRef := fbAxisRef[2],
                                        iMotionLogger := fbMotionLogger[2],
                                        iPersistentDataStorage := fbPersistentDataStorage[2]
                                    ) :=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#3S);
    fbAbsoluteMoveHaltTimer: TON := (PT:=T#100MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

fbMotionStage(); // Call stage logic cyclically

// State machine for staged assertions
CASE nTestStep OF
    // Interlock error check
    0:
        IF fbMotionStage.ExMotionStatus.bInterlocksError THEN
            AssertTrue(
                Condition := fbMotionStage.stMotionStatus.bError,
                Message   := 'Interlock error must be raised #2'
            );
            AssertEquals_UDINT(
                Expected := 11,
                Actual   := fbMotionStage.stMotionStatus.nErrorId,
                Message  := 'Interlock error code is 11 #3'
            );		
        END_IF
        nTestStep := 1;

    // Reset, enable limits and interlocks
    1:
        fbMotionStage.Reset();
        fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
        // Compiler shouldn't allow property set if property is get-only 
        // (review behavior: see your original comments).
        nTestStep := 2;	

    // After abort, error should be cleared
    2:
        IF fbMotionStage.ExMotionStatus.bAbortDone THEN
            AssertFalse(
                Condition := fbMotionStage.stMotionStatus.bError,
                Message   := 'Error must cleared #4'
            );
            AssertEquals_UDINT(
                Expected := 0,
                Actual   := fbMotionStage.stMotionStatus.nErrorId,
                Message  := 'error ID must 0 #5'
            );
            nTestStep := 3;	
        END_IF

    // Command an absolute move
    3:
        fbMotionStage.AbsoluteMove(
            Position := 1000.0,
            Velocity := 50.0,
            Acceleration := 200.0,
            Deceleration := 200.0
        );
        fbAbsoluteMoveHaltTimer.IN := TRUE;
        nTestStep := 4;

    // After short timer, send Halt
    4:
        IF fbAbsoluteMoveHaltTimer.Q THEN
            fbMotionStage.Halt();
            fbAbsoluteMoveHaltTimer.IN := FALSE;
            nTestStep := 5;
        END_IF

    // After move finishes, check abort status and flags
    5:
        IF fbMotionStage.ExMotionStatus.bIdling THEN
            AssertTrue(
                Condition := fbMotionStage.ExMotionStatus.bAborted,
                Message   := 'Move must be aborted #8'
            );
            AssertFalse(
                Condition := fbMotionStage.stMotionStatus.bBusy,
                Message   := 'Move request must be canceled #9'
            );
            AssertFalse(
                Condition := fbMotionStage.stExMotionStatus.bExecute,
                Message   := 'Move request must cleared #10'
            );
            nTestStep := 6;
        END_IF	
END_CASE

// Cyclically call timer FBs
fbTestTimer();
fbAbsoluteMoveHaltTimer();

// End test or handle timeout
IF nTestStep = 6 THEN
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdAndMoveOkIfResetThenAbortMove_Test1" Id="{65f1b0b0-0c30-4329-b7d2-5d137b5808f7}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdAndMoveOkIfResetThenAbortMove_Test1
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'TEST1',
                                        AxisRef := fbAxisRef[1],
                                        iMotionLogger := fbMotionLogger[1],
                                        iPersistentDataStorage := fbPersistentDataStorage[1]
                                    ):=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#3S);
    fbAbsoluteMoveResetTimer: TON := (PT:=T#500MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// motion stage block
fbMotionStage();

// Main test state machine
CASE nTestStep OF
    // === Interlock Fault Test ===
    0:
        IF fbMotionStage.ExMotionStatus.bInterlocksError THEN
            AssertTrue(
                Condition := fbMotionStage.stMotionStatus.bError,
                Message := 'Interlock error must be raised #1'
            );
            AssertEquals_UDINT(
                Expected := 11,
                Actual := fbMotionStage.stMotionStatus.nErrorId,
                Message := 'Interlock error code is 11 #2'
            );
        END_IF
        nTestStep := nTestStep + 1;
    
    // === Reset and Enable Features ===
    1:
        fbMotionStage.Reset();
        fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
        // Note: Trying to write to a property with 'GET' only should fail! See notes below.
        // fbMotionStage.MotionStatus.bExecute := TRUE; // Should be forbidden if it's a read-only property

        nTestStep := nTestStep + 1;    

    // === Abort Done/Status Check ===
    2:
        IF fbMotionStage.ExMotionStatus.bAbortDone THEN
            AssertFalse(
                Condition := fbMotionStage.stMotionStatus.bError,
                Message := 'Error must be cleared #3'
            );
            AssertEquals_UDINT(
                Expected := 0,
                Actual := fbMotionStage.stMotionStatus.nErrorId,
                Message := 'error ID must be 0 #4'
            );
            nTestStep := nTestStep + 1;    
        END_IF

    // === Absolute Move Request ===
    3:
        fbMotionStage.AbsoluteMove(
            Position := 10000.0,
            Velocity := 50.0,
            Acceleration := 500.0,
            Deceleration := 500.0
        );
        fbAbsoluteMoveResetTimer.IN := TRUE;
        nTestStep := nTestStep + 1;

    // === Move Reset after Timer ===
    4:
        IF fbAbsoluteMoveResetTimer.Q THEN
            fbMotionStage.Reset();
            fbAbsoluteMoveResetTimer.IN := FALSE;
            nTestStep := nTestStep + 1;
        END_IF

    // === Move Done/Abort Confirmation ===
    5:
        IF fbMotionStage.stExMotionStatus.bAbortDone THEN
            nTestStep := nTestStep + 1;
        END_IF
	6:
		IF fbMotionStage.stExMotionStatus.bAborted THEN
            AssertFalse(
                Condition := fbMotionStage.stMotionStatus.bBusy,
                Message := 'Move request must be canceled #6'
            );
            AssertFalse(
                Condition := fbMotionStage.stExMotionStatus.bExecute,
                Message := 'Move request must be cleared #7'
            );
            nTestStep := nTestStep + 1;
		END_IF
END_CASE

// Update timers
fbTestTimer();
fbAbsoluteMoveResetTimer();

// Test Completion Handlers
IF nTestStep = 7 THEN
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdAndMoveOkMoveToTarget1ThenTarget2_Test3" Id="{440f6e54-0647-423b-b13a-da4723a87f92}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdAndMoveOkMoveToTarget1ThenTarget2_Test3
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test3',
                                        AxisRef := fbAxisRef[3],
                                        iMotionLogger := fbMotionLogger[3],
                                        iPersistentDataStorage := fbPersistentDataStorage[3]
                                    ):=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#10S);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: // Enable safety interlocks and hardware limits
        fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;

    1: // Issue initial absolute move to position 100.0 with no backlash
        fbMotionStage.AbsoluteMove(
            Position := 100.0,
            Velocity := 50.0,
            Acceleration := 500.0,
            Deceleration := 500.0
        );
        nTestStep := 2;

    2: // Wait for move done
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(fbMotionStage.MotionCmd.fPosition - fbAxisRef[3].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #1'
            );
            nTestStep := 3;
        END_IF

    3: // When idling, perform another absolute move
        IF fbMotionStage.ExMotionStatus.bIdling THEN
            fbMotionStage.AbsoluteMove(
                Position := 320.0,
                Velocity := 50.0,
                Acceleration := 500.0,
                Deceleration := 500.0
            );
            nTestStep := 4;
        END_IF

    4: // Wait for second move done
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(fbMotionStage.MotionCmd.fPosition - fbAxisRef[3].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #2'
            );
            nTestStep := 5;
          END_IF

END_CASE

fbTestTimer();
fbMotionStage();

IF nTestStep = 5 THEN
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdAndValidInterlocksThenMoveToTarget_Test4" Id="{cdd9f552-1db5-4431-b2af-97cd2a62ee74}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdAndValidInterlocksThenMoveToTarget_Test4
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test4',
                                        AxisRef := fbAxisRef[4],
                                        iMotionLogger := fbMotionLogger[4],
                                        iPersistentDataStorage := fbPersistentDataStorage[4]
                                    ):=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#3S);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0: // Enable safety interlocks and hardware limits
        fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;

    1: // Issue initial absolute move to position 100.0 with no backlash
        fbMotionStage.AbsoluteMove(
            Position := 100.0,
            Velocity := 50.0,
            Acceleration := 500.0,
            Deceleration := 500.0
        );
        nTestStep := 2;

    2: // Wait for move done
        IF fbMotionStage.stMotionStatus.bDone THEN
            AssertTrue(
                Condition := ABS(fbMotionStage.MotionCmd.fPosition - fbAxisRef[4].NcToPlc.ActPos) < 0.001,
                Message := 'Target position not reached #1'
            );
            nTestStep := 3;
        END_IF
END_CASE

fbTestTimer();
fbMotionStage();

IF nTestStep = 3 THEN
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdValidInterlockAndWrongMotionParamsThenGotoErrorStateIfResetThenGotoInitState_Test5" Id="{2569c164-e1b3-4f42-94dc-e83db426a5c4}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdValidInterlockAndWrongMotionParamsThenGotoErrorStateIfResetThenGotoInitState_Test5
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test5',
                                        AxisRef := fbAxisRef[5],
                                        iMotionLogger := fbMotionLogger[5],
                                        iPersistentDataStorage := fbPersistentDataStorage[5]
                                    ):=(SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#3S);
    fbAbsoluteMoveTimer: TON := (PT:=T#50MS);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF
    0:
        fbMotionStage.EnableLimits(
			BackwardEnable:=TRUE, 
			ForwardEnable:=TRUE,
			HomeEnable:=FALSE
		);
        fbMotionStage.EnableInterlocks();
        nTestStep := 1;
	1:// Issue initial absolute move to position 100.0 with no backlash
        fbMotionStage.AbsoluteMove(
            Position := 100.0,
            Velocity := 0.0,
            Acceleration := 500.0,
            Deceleration := 500.0
        );
		nTestStep := 2;
	2:
		IF (fbMotionStage.stExMotionStatus.eDriveState=E_MoveState.ERROR) THEN
			nTestStep := 3;
		END_IF
END_CASE
fbMotionStage();
fbTestTimer();
fbAbsoluteMoveTimer();


IF nTestStep = 3 THEN

TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="OverallStageFeaturesAndOperationalTests_Test17" Id="{e31f4be0-4448-40c8-b5a5-bf90095b8839}">
      <Declaration><![CDATA[METHOD PRIVATE OverallStageFeaturesAndOperationalTests_Test17
VAR_INST
   fbMotionStage : FB_MotionStageNC(	sName := 'Test17',
                                        AxisRef := fbAxisRef[17],
                                        iMotionLogger := fbMotionLogger[17],
                                        iPersistentDataStorage := fbPersistentDataStorage[17]
                                    ) := (SaveAxisParams := FALSE);
									
    fbTestTimer: TON := (IN:=TRUE, PT:=T#180S);
    fbResetTimer: TON := (IN:=FALSE, PT:=T#500MS);;
	fbInMotionTimer : TON := (IN:=FALSE, PT:=T#800MS);;
    fbCamSwitchPulserSearch : TON := (IN:=FALSE, PT:=T#1000MS);
    fbCamSwitchPulserSync: TON := (IN:=FALSE, PT:=T#2000MS);
    nTestStep : INT;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

CASE nTestStep OF

/// ------------ INITIAL SETUP ---------------
0:
    fbMotionStage.EnableLimits(
        BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := FALSE);
    fbMotionStage.EnableInterlocks();
    nTestStep := 1;

/// ------- 3 FAST ABSOLUTE MOVES ------------
/// (All moves <= 50 units, velocities set for sub-second moves)
1:
    fbMotionStage.AbsoluteMove(Position := 10.0, Velocity := 50.0, Acceleration := 200.0, Deceleration := 200.0);
    nTestStep := 2;
2:
    IF fbMotionStage.stMotionStatus.bDone THEN
        AssertTrue(ABS(10.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#1');
        nTestStep := 3;
    END_IF
3:
    fbMotionStage.AbsoluteMove(Position := -8.0, Velocity := 50.0, Acceleration := 200.0, Deceleration := 200.0);
    nTestStep := 4;
4:
    IF fbMotionStage.stMotionStatus.bDone THEN
        AssertTrue(ABS(-8.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#2');
        nTestStep := 5;
    END_IF
5:
    fbMotionStage.AbsoluteMove(Position := 15.0, Velocity := 50.0, Acceleration := 150.0, Deceleration := 150.0);
    nTestStep := 6;
6:
    IF fbMotionStage.stMotionStatus.bDone THEN
        AssertTrue(ABS(15.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#3');
        nTestStep := 7;
    END_IF

/// -------- HALT and RESET POS/NEG ------------

7:
    fbMotionStage.AbsoluteMove(Position := 18.0, Velocity := 70.0, Acceleration := 200.0, Deceleration := 200.0);
    fbInMotionTimer.PT := T#120MS;
    fbInMotionTimer.IN := TRUE;
    nTestStep := 8;
8:
    IF fbMotionStage.stMotionStatus.bBusy AND fbInMotionTimer.Q THEN
        fbMotionStage.Halt();
        fbInMotionTimer.IN := FALSE;
        nTestStep := 9;
    END_IF
9:
    IF fbMotionStage.stExMotionStatus.bAborted THEN
        AssertFalse(fbMotionStage.stMotionStatus.bBusy, 'Halt busy/fwd');
        nTestStep := 10;
    END_IF

10:
    fbMotionStage.AbsoluteMove(Position := -12.0, Velocity := 70.0, Acceleration := 200.0, Deceleration := 200.0);
    fbInMotionTimer.PT := T#120MS;
    fbInMotionTimer.IN := TRUE;
    nTestStep := 11;
11:
    IF fbMotionStage.stMotionStatus.bBusy AND fbInMotionTimer.Q THEN
        fbMotionStage.Halt();
        fbInMotionTimer.IN := FALSE;
        nTestStep := 12;
    END_IF
12:
    IF fbMotionStage.stExMotionStatus.bAborted THEN
        AssertFalse(fbMotionStage.stMotionStatus.bBusy, 'Halt busy/bwd');
        nTestStep := 13;
    END_IF

13:
    fbMotionStage.AbsoluteMove(Position := 21.0, Velocity := 70.0, Acceleration := 200.0, Deceleration := 200.0);
    fbInMotionTimer.PT := T#120MS;
    fbInMotionTimer.IN := TRUE;
    nTestStep := 14;
14:
    IF fbMotionStage.stMotionStatus.bBusy AND fbInMotionTimer.Q THEN
        fbMotionStage.Reset();
        fbInMotionTimer.IN := FALSE;
        nTestStep := 15;
    END_IF
15:
    IF fbMotionStage.stExMotionStatus.bAborted THEN
        AssertFalse(fbMotionStage.stMotionStatus.bBusy, 'Reset busy/fwd');
        nTestStep := 16;
    END_IF

16:
    fbMotionStage.AbsoluteMove(Position := -22.0, Velocity := 70.0, Acceleration := 200.0, Deceleration := 200.0);
    fbInMotionTimer.PT := T#120MS;
    fbInMotionTimer.IN := TRUE;
    nTestStep := 17;
17:
    IF fbMotionStage.stMotionStatus.bBusy AND fbInMotionTimer.Q THEN
        fbMotionStage.Reset();
        fbInMotionTimer.IN := FALSE;
        nTestStep := 18;
    END_IF
18:
    IF fbMotionStage.stExMotionStatus.bAborted THEN
        AssertFalse(fbMotionStage.stMotionStatus.bBusy, 'Reset busy/bwd');
        nTestStep := 19;
    END_IF

/// -------- LIMIT HIT TEST (FORWARD THEN BACKWARD) ----------
19:
    fbMotionStage.AbsoluteMove(Position := 25.0, Velocity := 50.0, Acceleration := 120.0, Deceleration := 120.0);
    fbInMotionTimer.PT := T#120MS; fbInMotionTimer.IN := TRUE; nTestStep := 20;
20:
    IF fbMotionStage.stMotionStatus.bBusy AND fbInMotionTimer.Q THEN
        fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := FALSE, HomeEnable := FALSE);
        fbInMotionTimer.IN := FALSE; nTestStep := 21;
    END_IF
21:
    IF fbMotionStage.stMotionStatus.bWarning AND fbMotionStage.stExMotionStatus.bAborted THEN
        fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := FALSE);
        nTestStep := 22;
    END_IF
22: nTestStep := 23;

23:
    fbMotionStage.AbsoluteMove(Position := -25.0, Velocity := 50.0, Acceleration := 120.0, Deceleration := 120.0);
    fbInMotionTimer.PT := T#120MS; fbInMotionTimer.IN := TRUE; nTestStep := 24;
24:
    IF fbMotionStage.stMotionStatus.bBusy AND fbInMotionTimer.Q THEN
        fbMotionStage.EnableLimits(BackwardEnable := FALSE, ForwardEnable := TRUE, HomeEnable := FALSE);
        fbInMotionTimer.IN := FALSE; nTestStep := 25;
    END_IF
25:
    IF fbMotionStage.stMotionStatus.bWarning AND fbMotionStage.stExMotionStatus.bAborted THEN
        fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := FALSE);
        nTestStep := 26;
    END_IF
26: nTestStep := 27;

/// ------------- Home+Move Alternation: All major home modes ------------
/// (Home, then absolute move. All positions ~10-30 units, velocities >= 50.)
27:
    fbMotionStage.Home(HomePosition := 10.0, HomeMode := E_EpicsHomeCmd.LOW_LIMIT);
    fbCamSwitchPulserSearch.IN := TRUE; nTestStep := 28;
28:
    IF fbCamSwitchPulserSearch.Q THEN
        fbMotionStage.EnableLimits(BackwardEnable := FALSE, ForwardEnable := TRUE, HomeEnable := FALSE);
        fbCamSwitchPulserSearch.IN := FALSE; fbCamSwitchPulserSync.IN := TRUE;
        nTestStep := 29;
    END_IF
29:
    IF fbCamSwitchPulserSync.Q THEN
        fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := FALSE);
        fbCamSwitchPulserSync.IN := FALSE; nTestStep := 30;
    END_IF
30:
    IF fbMotionStage.stMotionStatus.bDone THEN
        AssertTrue(fbAxisRef[17].Status.Homed, 'Home#1 (LOW_LIMIT): Axis not calibrated'); 
		AssertEquals_LREAL(Delta := 0.001, Expected := 10.0, Actual := fbAxisRef[17].NcToPlc.ActPos, Message :='Home#1: Not at expected home');
        nTestStep := 31;
    END_IF
31: 
	fbMotionStage.AbsoluteMove(Position := 20.0, Velocity := 50.0, Acceleration := 200.0, Deceleration := 200.0);
	nTestStep := 32;
32: 
	IF fbMotionStage.stMotionStatus.bDone THEN
		AssertTrue(ABS(20.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#4: Target position not reached after home');
		nTestStep := 33;
	END_IF

33: 
	fbMotionStage.Home(HomePosition := 25.0, HomeMode := E_EpicsHomeCmd.HIGH_LIMIT);
	fbCamSwitchPulserSearch.IN := TRUE; 
	nTestStep := 34;
34: 
	IF fbCamSwitchPulserSearch.Q THEN 
		fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := FALSE, HomeEnable := FALSE);
		fbCamSwitchPulserSearch.IN := FALSE;
		fbCamSwitchPulserSync.IN := TRUE;
		nTestStep := 35;
	END_IF
35: 
	IF fbCamSwitchPulserSync.Q THEN
		fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := FALSE);
		fbCamSwitchPulserSync.IN := FALSE;
		nTestStep := 36;
	END_IF
36: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
		AssertTrue(fbAxisRef[17].Status.Homed, 'Home#2 (HIGH_LIMIT): Axis not calibrated');
		AssertEquals_LREAL(Delta := 0.001, Expected := 25.0, Actual := fbAxisRef[17].NcToPlc.ActPos, Message := 'Home#2: Not at expected home'); 
		nTestStep := 37; 
	END_IF
37: 
	fbMotionStage.AbsoluteMove(Position := -20.0, Velocity := 50.0, Acceleration := 200.0, Deceleration := 200.0); 
	nTestStep := 38;
38: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
		AssertTrue(ABS(-20.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#5: Target position not reached after home');
		nTestStep := 39; 
	END_IF

39:
    fbMotionStage.Home(HomePosition := 12.0, HomeMode := E_EpicsHomeCmd.HOME_VIA_LOW);
    fbCamSwitchPulserSearch.IN := TRUE; nTestStep := 40;
40: 
	IF fbCamSwitchPulserSearch.Q THEN 
		fbMotionStage.EnableLimits(BackwardEnable := FALSE, ForwardEnable := TRUE, HomeEnable := FALSE); 
		fbCamSwitchPulserSearch.IN := FALSE; 
		fbCamSwitchPulserSync.IN := TRUE; 
		nTestStep := 41; 
	END_IF
41: 
	IF fbCamSwitchPulserSync.Q THEN
		fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := FALSE);
		fbCamSwitchPulserSync.IN := FALSE;
		fbCamSwitchPulserSearch.IN := TRUE;
		nTestStep := 42;
	END_IF
42: 
	IF fbCamSwitchPulserSearch.Q THEN
		fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := TRUE);
		fbCamSwitchPulserSearch.IN := FALSE;
		fbCamSwitchPulserSync.IN := TRUE;
		nTestStep := 43;
	END_IF
43: 
	IF fbCamSwitchPulserSync.Q THEN 
		fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := FALSE);
		fbCamSwitchPulserSync.IN := FALSE; 
		nTestStep := 44; 
	END_IF
44: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
		AssertTrue(fbAxisRef[17].Status.Homed, 'Home#3 (HOME_VIA_LOW): Axis not calibrated'); 
		AssertEquals_LREAL(Delta := 0.001, Expected := 12.0, Actual := fbAxisRef[17].NcToPlc.ActPos, Message := 'Home#3: Not at expected home');
		nTestStep := 45; 
	END_IF
45: 
	fbMotionStage.AbsoluteMove(Position := 25.0, Velocity := 50.0, Acceleration := 200.0, Deceleration := 200.0); 
	nTestStep := 46;
46: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
		AssertTrue(ABS(25.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#6: Target position not reached after home');
		nTestStep := 47; 
	END_IF

47:
    fbMotionStage.Home(HomePosition := -15.0, HomeMode := E_EpicsHomeCmd.HOME_VIA_HIGH);
    fbCamSwitchPulserSearch.IN := TRUE; nTestStep := 48;
48: 
	IF fbCamSwitchPulserSearch.Q THEN 
		fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := FALSE, HomeEnable := FALSE);
		fbCamSwitchPulserSearch.IN := FALSE;
		fbCamSwitchPulserSync.IN := TRUE;
		nTestStep := 49; 
	END_IF
49: 
	IF fbCamSwitchPulserSync.Q THEN 
		fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := FALSE);
		fbCamSwitchPulserSync.IN := FALSE;
		fbCamSwitchPulserSearch.IN := TRUE;
		nTestStep := 50;
	END_IF
50: 
	IF fbCamSwitchPulserSearch.Q THEN
		fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := TRUE);
		fbCamSwitchPulserSearch.IN := FALSE;
		fbCamSwitchPulserSync.IN := TRUE;
		nTestStep := 51;
	END_IF
51: 
	IF fbCamSwitchPulserSync.Q THEN 
		fbMotionStage.EnableLimits(BackwardEnable := TRUE, ForwardEnable := TRUE, HomeEnable := FALSE);
		fbCamSwitchPulserSync.IN := FALSE;
		nTestStep := 52; 
	END_IF
52: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
		AssertTrue(fbAxisRef[17].Status.Homed, 'Home#4 (HOME_VIA_HIGH): Axis not calibrated');
		AssertEquals_LREAL(Delta := 0.001, Expected := -15.0, Actual := fbAxisRef[17].NcToPlc.ActPos, Message := 'Home#4: Not at expected home');
		nTestStep := 53; 
	END_IF
53: 
	fbMotionStage.AbsoluteMove(Position := -30.0, Velocity := 50.0, Acceleration := 200.0, Deceleration := 200.0);
	nTestStep := 54;
54: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
		AssertTrue(ABS(-30.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#7: Target position not reached after home'); 
		nTestStep := 55;
	END_IF

55:
    fbMotionStage.Home(HomePosition := 30.0, HomeMode := E_EpicsHomeCmd.ABSOLUTE_SET); 
    nTestStep := 56;
56: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
		AssertTrue(fbAxisRef[17].Status.Homed, 'Home#5 (ABSOLUTE_SET): Axis not calibrated'); 
		AssertEquals_LREAL(Delta := 0.001, Expected := 30.0, Actual := fbAxisRef[17].NcToPlc.ActPos,  Message := 'Home#5: Not at expected home');
		nTestStep := 57; 
	END_IF
57: 
	fbMotionStage.AbsoluteMove(Position := 23.0, Velocity := 50.0, Acceleration := 200.0, Deceleration := 200.0);
	nTestStep := 58;
58: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
		AssertTrue(ABS(23.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#8: Target position not reached after home');
		nTestStep := 59;
	END_IF

// ---- Backlash Compensation: absolute moves ----
59: 
	fbMotionStage.EnableBacklashCompensation(UserEnable := TRUE, Compensation := 1.2);
	nTestStep := 60;
60: 
	fbMotionStage.AbsoluteMove(Position := 27.5, Velocity := 50.0, Acceleration := 100.0, Deceleration := 100.0);
	nTestStep := 61;
61: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
        AssertTrue(ABS(27.5 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#9:No comp fwd expected');
        AssertTrue((fbAxisRef[17].NcToPlc.ActPos - fbAxisRef[17].NcToPlc.ActPosWithoutPosCorrection) = 0.0, 'No compensation in this direction');
        nTestStep := 62; 
    END_IF
62: 
	fbMotionStage.AbsoluteMove(Position := 21.0, Velocity := 50.0, Acceleration := 100.0, Deceleration := 100.0);
	nTestStep := 63;
63: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
        AssertTrue(ABS(21.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#10: Target not reached'); 
        AssertTrue(((fbAxisRef[17].NcToPlc.ActPos - fbAxisRef[17].NcToPlc.ActPosWithoutPosCorrection)-1.2) < 0.001, 
                   'Compensation 1.2 not applied in reverse'); 
        nTestStep := 64; 
    END_IF
64: 
	fbMotionStage.EnableBacklashCompensation(UserEnable := FALSE, Compensation := 0.0);
	nTestStep := 65;
65: 
	fbMotionStage.AbsoluteMove(Position := -20.0, Velocity := 50.0, Acceleration := 100.0, Deceleration := 100.0);
	nTestStep := 66;
66: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
        AssertTrue(ABS(-20.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#11: Target not reached (no comp)'); 
        AssertTrue((fbAxisRef[17].NcToPlc.ActPos - fbAxisRef[17].NcToPlc.ActPosWithoutPosCorrection) = 0.0, 'Compensation should be disabled'); 
        nTestStep := 67; 
    END_IF
67: 
	fbMotionStage.EnableBacklashCompensation(UserEnable := TRUE, Compensation := -1.7);
	nTestStep := 68;
68: 
	fbMotionStage.AbsoluteMove(Position := -30.0, Velocity := 50.0, Acceleration := 100.0, Deceleration := 100.0);
	nTestStep := 69;
69: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
        AssertTrue(ABS(-30.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#12: Target not reached, comp negative'); 
        AssertTrue((fbAxisRef[17].NcToPlc.ActPos - fbAxisRef[17].NcToPlc.ActPosWithoutPosCorrection) = 0.0, 'No comp fwd for neg setting'); 
        nTestStep := 70; 
    END_IF
70: 
	fbMotionStage.AbsoluteMove(Position := 5.0, Velocity := 50.0, Acceleration := 100.0, Deceleration := 100.0);
	nTestStep := 71;
71: 
	IF fbMotionStage.stMotionStatus.bDone THEN 
        AssertTrue(ABS(5.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01, 'Move#13: Target not reached (comp negative, rev)'); 
        AssertTrue(((fbAxisRef[17].NcToPlc.ActPos - fbAxisRef[17].NcToPlc.ActPosWithoutPosCorrection)-1.7) < 0.001, 'Compensation -1.7 not applied'); 
        nTestStep := 72; 
    END_IF
72:
	fbMotionStage.EnableBacklashCompensation(UserEnable := FALSE, Compensation := 0.0);
	nTestStep := 73;
// --- Absolute Move with ZERO Velocity triggers error ---
73:
    fbMotionStage.AbsoluteMove(
        Position := 10.0,
        Velocity := 0.0,
        Acceleration := 100.0,
        Deceleration := 100.0
    );
    nTestStep := 74;

74:
    IF fbMotionStage.stMotionStatus.bError THEN
        AssertTrue(
            fbMotionStage.stMotionStatus.nErrorId = 16#4359,
            'Not the expected NC error message for zero velocity'
        );
        fbMotionStage.Reset();
        nTestStep := 75;
    END_IF

75:
    IF NOT fbMotionStage.stMotionStatus.bError THEN
        AssertFalse(
            fbMotionStage.stMotionStatus.bError,
            'Error flag should be cleared after reset'
        );
        AssertTrue(
            fbMotionStage.stMotionStatus.sErrorMessage = '',
            'Error message should be cleared after reset'
        );
        nTestStep := 76;
    END_IF

76:
    fbMotionStage.AbsoluteMove(
        Position := 15.0,
        Velocity := 50.0,
        Acceleration := 100.0,
        Deceleration := 100.0
    );
    nTestStep := 77;

77:
    IF fbMotionStage.stMotionStatus.bDone THEN
        AssertTrue(
            ABS(15.0 - fbAxisRef[17].NcToPlc.ActPos) < 0.01,
            'Recovery Move: Target position not reached after valid velocity'
        );
        nTestStep := 78;
    END_IF
END_CASE

fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbInMotionTimer();
fbTestTimer();
fbMotionStage();

IF nTestStep = 78 THEN
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(FALSE, CONCAT('Timed out at step: ', TO_STRING(nTestStep)));
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>