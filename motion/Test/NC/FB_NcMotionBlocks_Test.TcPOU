<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_NcMotionBlocks_Test" Id="{dc41a27c-ab9f-47fb-bcb5-3fed2b1c906b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_NcMotionBlocks_Test EXTENDS FB_TestSuite
VAR
    fbAxisRef : ARRAY [1..16] OF AXIS_REF;
    fbLimSwStatus : ARRAY [1..16] OF FB_LimSwStatus_TestDouble;
    fbMotionLogger : ARRAY [1..16] OF FB_MotionLogger_TestDouble;
    fbPower : ARRAY [1..16] OF FB_PowerNC[	(AxisRef := fbAxisRef[1], iMotionLogger:= fbMotionLogger[1]),
                                            (AxisRef := fbAxisRef[2], iMotionLogger:= fbMotionLogger[2]),
                                            (AxisRef := fbAxisRef[3], iMotionLogger:= fbMotionLogger[3]),
                                            (AxisRef := fbAxisRef[4], iMotionLogger:= fbMotionLogger[4]),
                                            (AxisRef := fbAxisRef[5], iMotionLogger:= fbMotionLogger[5]),
                                            (AxisRef := fbAxisRef[6], iMotionLogger:= fbMotionLogger[6]),
                                            (AxisRef := fbAxisRef[7], iMotionLogger:= fbMotionLogger[7]),
                                            (AxisRef := fbAxisRef[8], iMotionLogger:= fbMotionLogger[8]),
											(AxisRef := fbAxisRef[9], iMotionLogger:= fbMotionLogger[9]),
                                            (AxisRef := fbAxisRef[10], iMotionLogger:= fbMotionLogger[10]),
                                            (AxisRef := fbAxisRef[11], iMotionLogger:= fbMotionLogger[11]),
                                            (AxisRef := fbAxisRef[12], iMotionLogger:= fbMotionLogger[12]),
                                            (AxisRef := fbAxisRef[13], iMotionLogger:= fbMotionLogger[13]),
                                            (AxisRef := fbAxisRef[14], iMotionLogger:= fbMotionLogger[14]),
                                            (AxisRef := fbAxisRef[15], iMotionLogger:= fbMotionLogger[15]),
                                            (AxisRef := fbAxisRef[16], iMotionLogger:= fbMotionLogger[16])
                                            ];
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[GivenHomeCmdAbsoluteSetModeThenSetHomeDoneAndPositionToUserDefineOffset_Test1();
GivenHomeCmdBacklashCompensationInactiveThenMoveStartandCompletesWithBacklashCompensationDisabled_Test2();
GivenHomeCmdHomeViaHighModeAndHomeSwPulseThenMoveToUserDefineOffset_Test3();
GivenHomeCmdHomeViaHighModeForwardSwPulseBeforeHomeSwPulseThenMoveToUserDefineOffset_Test4();
GivenHomeCmdHomeViaLowModeAndHomeSwPulseThenMoveToUserDefineOffset_Test5();
GivenHomeCmdHomeViaLowModeBackwardSwPulseBeforeHomeSwPulseThenMoveToUserDefineOffset_Test6();
GivenHomeCmdLowLimitModeAndABackwardSwPulseThenHomeDoneAndPositionSetToUserDefineOffset_Test7();
GivenHomeCmdNoneModeThenSetHomeFlag_Test8();
GivenHomeCmdSetToHighLimitAndHighLimitPulseThenSetHomeDoneAndPositionToUserDefineOffset_Test9();
GivenMoveCmdNegativeBacklashCompensationActiveThenReverseMoveIsCompensated_Test10();
GivenMoveCmdPositiveBacklashCompensationActiveThenReverseMoveIsCompensated_Test11();
GivenDirectionalPowerEnabledAndBackwardAbsoluteMoveIfNegativeLimitHitThenAbortMove_Test12();
GivenDirectionalPowerEnabledAndForwardAbsoluteMoveIfPositiveLimitHitThenAbortMove_Test13();
GivenPowerIsEnabledAndCompletedAbsoluteMoveThenMoveAbsoluteDoneStatusRetained_Test14();
GivenPowerIsEnabledAndAbsoluteMoveStartedIfHaltSignalThenMoveIsAbortedAndHaltDoneIsRetained_Test15();
GivenPowerIsEnabledAbsoluteMoveIfResetThenMoveIsAbortedAndResetDoneIsRetained_Test16();

// 

]]></ST>
    </Implementation>
    <Method Name="GivenDirectionalPowerEnabledAndBackwardAbsoluteMoveIfNegativeLimitHitThenAbortMove_Test12" Id="{2b29e441-0e05-443a-bf4f-6018918ec3e3}">
      <Declaration><![CDATA[METHOD PRIVATE GivenDirectionalPowerEnabledAndBackwardAbsoluteMoveIfNegativeLimitHitThenAbortMove_Test12
VAR_INST
    // Subject under tests
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[12],  iMotionLogger:= fbMotionLogger[12]);
    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    nTestStateStep : INT;
    fbLimtHitTimer : TON := (PT := T#1S, IN := FALSE);
    fExpectedPosition: LREAL := 50.0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Cyclically call these every scan for correct PLC logic
fbPower[12].Power(
    Enable := TRUE,
    Enable_Positive := fbLimSwStatus[12].LimitForwardEnable,
    Enable_Negative := fbLimSwStatus[12].LimitBackwardEnable,
    Override := 100
);

// Stepwise state machine logic
CASE nTestStateStep OF
    0 : // Wait for power on before initiating move
        IF fbPower[12].PowerIsEnabled THEN
            nTestStateStep := 1;
        END_IF

    1 : // Issue negative move and start timer
        fbMoveAbsolute.MoveAbsolute(
            Position := -150.0,
            Velocity := 100,
            Acceleration := 200,
            Deceleration := 200
        );
        fbLimtHitTimer.IN := TRUE;
        nTestStateStep := 2;

    2 : // After timer, simulate limit hit
        IF fbLimtHitTimer.Q THEN
            fbLimSwStatus[12].LimitBackwardEnable := FALSE; // Simulate the axis hitting the negative limit
            nTestStateStep := 3;
        END_IF

    3 : // Wait until move is aborted by limit hit
        IF fbMoveAbsolute.Aborted THEN
            nTestStateStep := 4;
        END_IF

    4 : // Assertions below once test finished
END_CASE

// Cyclic calls required for correct behavior
fbLimtHitTimer();
fbTestTimer();
fbAxisRef[12].ReadStatus();
fbMoveAbsolute();

// Final assertion and test finish
IF nTestStateStep = 4 THEN
    AssertTrue(
        Condition := fbAxisRef[12].Status.HasBeenStopped,
        Message := 'Expected HasBeenStopped after move aborted by limit'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenDirectionalPowerEnabledAndForwardAbsoluteMoveIfPositiveLimitHitThenAbortMove_Test13" Id="{903b34b2-f5e3-4716-a670-9db554d02b7b}">
      <Declaration><![CDATA[METHOD PRIVATE GivenDirectionalPowerEnabledAndForwardAbsoluteMoveIfPositiveLimitHitThenAbortMove_Test13
VAR_INST

    // Subject under tests
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[13], iMotionLogger:= fbMotionLogger[13]);
    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    nTestStateStep : INT;
    fbLimtHitTimer : TON := (PT := T#1S, IN := FALSE);
    fExpectedPosition: LREAL := 50.0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Cyclically call these every scan for correct PLC logic
fbPower[13].Power(
    Enable := TRUE,
    Enable_Positive := fbLimSwStatus[13].LimitForwardEnable,
    Enable_Negative := fbLimSwStatus[13].LimitBackwardEnable,
    Override := 100
);

// Stepwise state machine logic
CASE nTestStateStep OF
    0 : // Wait for power on before initiating move
        IF fbPower[13].PowerIsEnabled THEN
            nTestStateStep := 1;
        END_IF

    1 : // Issue negative move and start timer
        fbMoveAbsolute.MoveAbsolute(
            Position := 150.0,
            Velocity := 100,
            Acceleration := 200,
            Deceleration := 200
        );
        fbLimtHitTimer.IN := TRUE;
        nTestStateStep := 2;

    2 : // After timer, simulate limit hit
        IF fbLimtHitTimer.Q THEN
            fbLimSwStatus[13].LimitForwardEnable := FALSE; // Simulate the axis hitting the negative limit
            nTestStateStep := 3;
        END_IF

    3 : // Wait until move is aborted by limit hit
        IF fbMoveAbsolute.Aborted THEN
            nTestStateStep := 4;
        END_IF
END_CASE

// Cyclic calls required for correct behavior
fbLimtHitTimer();
fbTestTimer();
fbAxisRef[13].ReadStatus();
fbMoveAbsolute();

// Final assertion and test finish
IF nTestStateStep = 4 THEN
    AssertTrue(
        Condition := fbAxisRef[13].Status.HasBeenStopped,
        Message := 'Expected HasBeenStopped after move aborted by limit'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdAbsoluteSetModeThenSetHomeDoneAndPositionToUserDefineOffset_Test1" Id="{d4754e57-693c-40b7-9460-2ffc5ab4a21b}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdAbsoluteSetModeThenSetHomeDoneAndPositionToUserDefineOffset_Test1
VAR_INST
    fbHome : FB_HomeNC(
		AxisRef:=fbAxisRef[1],
		iLimSwStatus:=fbLimSwStatus[1],
		iMotionLogger:=fbMotionLogger[1]
	):=(Mode:=E_EpicsHomeCmd.ABSOLUTE_SET);
    fbTestTimer : TON := (IN := TRUE, PT := T#8S);
    nTestStep : INT := 0;
    fExpectedPosition : LREAL := 20.0;
    fActPosition : LREAL := 0.0;
    bCalibrated : BOOL := FALSE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());
// FBs that must be invoked cyclically
fbLimSwStatus[1]();
fbMotionLogger[1]();
fbAxisRef[1].ReadStatus();
fbPower[1].Power(
    Enable := TRUE,
    Enable_Positive := fbLimSwStatus[1].LimitForwardEnable,
    Enable_Negative := fbLimSwStatus[1].LimitBackwardEnable,
    Override := 100.0
);
fbHome();
fbTestTimer(IN := TRUE);

// --- State Machine ---
CASE nTestStep OF
    0: // Enable power, then issue home command
        IF fbPower[1].PowerIsEnabled THEN
            fbHome.Home(Position := fExpectedPosition, BufferMode := MC_BufferMode.MC_Aborting);
            nTestStep := 1;
        END_IF

    1: // Wait for homing to complete
        IF fbHome.Done THEN
            nTestStep := 2;
        END_IF
END_CASE

// --- Test Completion: Assertion & Finish ---
IF nTestStep = 2 THEN
    bCalibrated := fbHome.Done;

    // Assert the axis is marked homed (calibrated)
    AssertEquals_BOOL(
        Expected := TRUE,
        Actual := fbAxisRef[1].Status.Homed,
        Message := 'Axis not calibrated #1'
    );

    // Assert the position matches expected
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fExpectedPosition,
        Actual := fbAxisRef[1].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdBacklashCompensationInactiveThenMoveStartandCompletesWithBacklashCompensationDisabled_Test2" Id="{d165f2d2-92b0-417e-9f05-e4578b84306f}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdBacklashCompensationInactiveThenMoveStartandCompletesWithBacklashCompensationDisabled_Test2
VAR_INST

    // Subjects under tests
    fbBacklashCompensation : FB_BacklashCompensationNC(
		AxisRef := fbAxisRef[2], 
		iMotionLogger:= fbMotionLogger[2]
	);

    fbHome : FB_HomeNC(
		AxisRef:=fbAxisRef[2],
		iLimSwStatus:=fbLimSwStatus[2],
		iMotionLogger:=fbMotionLogger[2]
	):=(Mode:=E_EpicsHomeCmd.HIGH_LIMIT);

    fbTestTimer : TON := (PT := T#5S, IN := TRUE);
    nTestStep : INT;
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#100MS);
    fbCamSwitchPulserSync: TON := (PT:=T#500MS);
    bHomingOverride: BOOL := TRUE;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Directional enables must always be TRUE during homing via override.
// 'bHomingOverride' should be TRUE while homing is active.
fbPower[2].Power(
    Enable := TRUE,
    Enable_Positive := bHomingOverride OR fbLimSwStatus[2].LimitForwardEnable,
    Enable_Negative := bHomingOverride OR fbLimSwStatus[2].LimitBackwardEnable,
    Override := 100
);

// == State Machine ==
CASE nTestStep OF
    0: // Enable backlash compensation, but it must be suppressed when homing
        fbBacklashCompensation.EnableBacklashCompensation(UserEnable := TRUE, Compensation := 1.0);
        nTestStep := 1;
    1: // Wait for power enable before issuing home command
        IF fbPower[2].PowerIsEnabled THEN
			fbBacklashCompensation.BacklashCompensation(Enable := FALSE, RampVelo := 10.0);
            // Set override for homing
            bHomingOverride := TRUE;
            // Initiate homing sequence
			
            fbHome.Home(Position := 20.0, BufferMode := MC_Aborting);
            nTestStep := 2;
        END_IF
    2: // Wait until homing is busy (started)
        IF fbHome.Busy THEN
            AssertFalse(
                Condition := fbBacklashCompensation.Status,
                Message := 'Backlash must be disabled after homing started #2'
            );
            nTestStep := 3;
        END_IF
    3: // Simulate forward cam switch pulse for homing
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[2].LimitForwardEnable := FALSE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 4;
        END_IF
    4: // Simulate cam switch releasing back to TRUE
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[2].LimitForwardEnable := TRUE;
            nTestStep := 5;
        END_IF
    5: // When homing is done, stop override
        IF fbHome.Done THEN
            bHomingOverride := FALSE;
            nTestStep := 6;
        END_IF
END_CASE

// -- Cyclic calls to all dependencies --
fbAxisRef[2].ReadStatus();
fbBacklashCompensation();
fbHome();
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();

// -- Assertion and test finish --
IF nTestStep = 6 THEN
    AssertTrue(
        Condition := (fbAxisRef[2].NcToPlc.ActPos - fbAxisRef[2].NcToPlc.ActPosWithoutPosCorrection) = 0,
        Message := 'Backlash compensation must be enabled #3'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdHomeViaHighModeAndHomeSwPulseThenMoveToUserDefineOffset_Test3" Id="{b2085644-7959-47fa-a9ee-a37dd04f378f}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdHomeViaHighModeAndHomeSwPulseThenMoveToUserDefineOffset_Test3
VAR_INST
    fbHome : FB_HomeNC(
		AxisRef:=fbAxisRef[3],
		iLimSwStatus:=fbLimSwStatus[3],
		iMotionLogger:=fbMotionLogger[3]
	) := ( Mode:=E_EpicsHomeCmd.HOME_VIA_HIGH );
	
    fbTestTimer: TON := (IN:=TRUE, PT:=T#5S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
    fExpectedPosition : LREAL := 20.0;
    fActPosition : LREAL;
    bCalibrated: BOOL;
    // reset this when error or homeDone
    bHomingOverride : BOOL := TRUE;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Cyclic block calls
fbLimSwStatus[3]();
fbMotionLogger[3]();

fbPower[3].Power(
    Enable := TRUE,
    Enable_Positive := bHomingOverride OR fbLimSwStatus[3].LimitForwardEnable,
    Enable_Negative := bHomingOverride OR fbLimSwStatus[3].LimitBackwardEnable,
    Override := 100.0
);

CASE nTestStep OF
    0:
        IF fbPower[3].PowerIsEnabled THEN
            // Initiate Home command when power is ready
            fbHome.Home(Position := fExpectedPosition, BufferMode := MC_BufferMode.MC_Aborting);
            nTestStep := 1;
        END_IF
    1:
        // Simulate forward cam switch pulse for homing
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[3].LimitHome := TRUE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 2;
        END_IF
    2:
        // Clear home limit after sync pulse
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[3].LimitHome := FALSE;
            nTestStep := 3;
        END_IF
    3:
        // Wait for the home sequence to finish
        IF fbHome.Done THEN
            nTestStep := 4;
        END_IF
END_CASE

// Cyclic calls
fbAxisRef[3].ReadStatus();
fbPower[3]();
fbHome();
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();

IF nTestStep = 4 THEN
    bCalibrated := fbHome.Done;
    AssertEquals_BOOL(
        Expected := TRUE,
        Actual := fbAxisRef[3].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fExpectedPosition,
        Actual := fbAxisRef[3].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdHomeViaHighModeForwardSwPulseBeforeHomeSwPulseThenMoveToUserDefineOffset_Test4" Id="{504926c1-1919-481e-bdb9-25f2e0554127}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdHomeViaHighModeForwardSwPulseBeforeHomeSwPulseThenMoveToUserDefineOffset_Test4
VAR_INST
    fbHome : FB_HomeNC(
		AxisRef:=fbAxisRef[4],
		iLimSwStatus:=fbLimSwStatus[4],
		iMotionLogger:=fbMotionLogger[4]
	) := ( Mode := E_EpicsHomeCmd.HOME_VIA_HIGH );
	
    fbTestTimer: TON := (IN:=TRUE, PT:=T#5S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
    fExpectedPosition : LREAL := 20.0;
    fActPosition : LREAL;
    bCalibrated: BOOL;
    // reset this when error or homeDone
    bHomingOverride : BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Cyclic preparation and block invocation
fbAxisRef[4].ReadStatus();
fbLimSwStatus[4]();
fbMotionLogger[4]();
fbPower[4].Power(
    Enable := TRUE,
    Enable_Positive := bHomingOverride OR fbLimSwStatus[4].LimitForwardEnable,
    Enable_Negative := bHomingOverride OR fbLimSwStatus[4].LimitForwardEnable, // Note: both positive and negative use ForwardEnable here
    Override := 100.0
);

// Stepwise homing process
CASE nTestStep OF
    0: // Await full power-up, start first stage home
        IF fbPower[4].PowerIsEnabled THEN
            fbHome.Home(Position := fExpectedPosition, BufferMode := MC_BufferMode.MC_Aborting);
            nTestStep := 1;
        END_IF
    1: // Simulate Forward Limit pulse (stage 1 complete)
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[4].LimitForwardEnable := FALSE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 2;
        END_IF
    2: // Release Forward Limit (simulate rising edge)
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[4].LimitForwardEnable := TRUE;
            nTestStep := 3;
        END_IF
    3: // When forward limit home is done, prepare for the home switch
        IF fbHome.LimHomeDone THEN
            fbCamSwitchPulserSearch.IN := TRUE;
            fbCamSwitchPulserSync.IN := FALSE;
            nTestStep := 4;
        END_IF
    4: // Simulate Home switch pulse
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[4].LimitHome := TRUE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 5;
        END_IF
    5: // Release Home switch
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[4].LimitHome := FALSE;
            nTestStep := 6;
        END_IF
    6: // Wait for homing full completion
        IF fbHome.Done THEN
            nTestStep := 7;
        END_IF
END_CASE

// Cyclic calls required for simulation and status updates
fbPower[4]();
fbHome();
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();

// Finish test if homing is complete (step 7), or timeout
IF nTestStep = 7 THEN
    bCalibrated := fbHome.Done;
    AssertEquals_BOOL(
        Expected := TRUE,
        Actual := fbAxisRef[4].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fExpectedPosition,
        Actual := fbAxisRef[4].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdHomeViaLowModeAndHomeSwPulseThenMoveToUserDefineOffset_Test5" Id="{40dcb32c-5f70-434b-a8dd-25a5277ca8f8}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdHomeViaLowModeAndHomeSwPulseThenMoveToUserDefineOffset_Test5
VAR_INST
    fbHome : FB_HomeNC(
		AxisRef:=fbAxisRef[5],
		iLimSwStatus:=fbLimSwStatus[5],
		iMotionLogger:=fbMotionLogger[5]
	) := ( Mode := E_EpicsHomeCmd.HOME_VIA_LOW );
	
    fbTestTimer: TON := (IN:=TRUE, PT:=T#5S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
    fExpectedPosition : LREAL := 20.0;
    fActPosition : LREAL;
	bCalibrated: BOOL;
    // reset this when error or homeDone
    bHomingOverride : BOOL := TRUE;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Cyclic status/logic blocks
fbLimSwStatus[5]();
fbMotionLogger[5]();

fbPower[5].Power(
    Enable := TRUE,
    Enable_Positive := bHomingOverride OR fbLimSwStatus[5].LimitForwardEnable,
    Enable_Negative := bHomingOverride OR fbLimSwStatus[5].LimitBackwardEnable,
    Override := 100.0
);

// State machine for homing by home switch
CASE nTestStep OF
    0: // Wait for power to enable before starting home sequence
        IF fbPower[5].PowerIsEnabled THEN
            fbHome.Home(Position := fExpectedPosition, BufferMode := MC_BufferMode.MC_Aborting);
            nTestStep := 1;
        END_IF
    1: // Simulate cam switch pulse: set home limit
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[5].LimitHome := TRUE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 2;
        END_IF
    2: // Simulate sync pulse: clear home limit
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[5].LimitHome := FALSE;
            nTestStep := 3;
        END_IF
    3: // Wait for homing to complete
        IF fbHome.Done THEN
            nTestStep := 4;
        END_IF
    4:
        // No actions; test finishes in the assertion below
END_CASE

// Always cycle these for PLC logic to work
fbAxisRef[5].ReadStatus();
fbPower[5]();
fbHome();
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();

// Assertions and test finish
IF nTestStep = 4 THEN
    bCalibrated := fbHome.Done;
    AssertEquals_BOOL(
        Expected := TRUE,
        Actual := fbAxisRef[5].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fExpectedPosition,
        Actual := fbAxisRef[5].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdHomeViaLowModeBackwardSwPulseBeforeHomeSwPulseThenMoveToUserDefineOffset_Test6" Id="{ce7122bb-2e16-4f97-b955-1e752383c80f}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdHomeViaLowModeBackwardSwPulseBeforeHomeSwPulseThenMoveToUserDefineOffset_Test6
VAR_INST
    fbHome : FB_HomeNC(
		AxisRef:=fbAxisRef[6],
		iLimSwStatus:=fbLimSwStatus[6],
		iMotionLogger:=fbMotionLogger[6]
	) := ( Mode:= E_EpicsHomeCmd.HOME_VIA_LOW );
	
    fbTestTimer: TON := (IN:=TRUE, PT:=T#5S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
    fExpectedPosition : LREAL := 20.0;
    fActPosition : LREAL;
	bCalibrated: BOOL;
    // reset this when error or homeDone
    bHomingOverride : BOOL := TRUE;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Always call these each cycle for correct PLC scan semantics
fbAxisRef[6].ReadStatus();
fbLimSwStatus[6]();
fbMotionLogger[6]();

fbPower[6].Power(
    Enable := TRUE,
    Enable_Positive := bHomingOverride OR fbLimSwStatus[6].LimitForwardEnable,
    Enable_Negative := bHomingOverride OR fbLimSwStatus[6].LimitBackwardEnable,
    Override := 100.0
);

// State machine for negative (backward) limit then home
CASE nTestStep OF
    0: // Wait for power ready, then start home
        IF fbPower[6].PowerIsEnabled THEN
            fbHome.Home(Position := fExpectedPosition, BufferMode := MC_BufferMode.MC_Aborting);
            nTestStep := 1;
        END_IF

    1: // Simulate cam pulse: deactivate backward limit
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[6].LimitBackwardEnable := FALSE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 2;
        END_IF

    2: // Reactivate backward limit on sync pulse
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[6].LimitBackwardEnable := TRUE;
            nTestStep := 3;
        END_IF

    3: // Wait for negative-limit home done, then prep second stage (home switch)
        IF fbHome.LimHomeDone THEN
            fbCamSwitchPulserSearch.IN := TRUE;
            fbCamSwitchPulserSync.IN := FALSE;
            nTestStep := 4;
        END_IF

    4: // Simulate home switch pulse
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[6].LimitHome := TRUE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 5;
        END_IF

    5: // Deactivate home switch after sync pulse
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[6].LimitHome := FALSE;
            nTestStep := 6;
        END_IF

    6: // Wait for full home sequence completion
        IF fbHome.Done THEN
            nTestStep := 7;
        END_IF

    7: // Test ends — handled below
END_CASE

// Cyclic calls
fbPower[6]();
fbHome();
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();

// Assertion and finish logic
IF nTestStep = 7 THEN
    bCalibrated := fbHome.Done;

    AssertEquals_BOOL(
        Expected := TRUE,
        Actual := fbAxisRef[6].Status.Homed,
        Message := 'Axis not calibrated #1'
    );

    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fExpectedPosition,
        Actual := fbAxisRef[6].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );

    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdLowLimitModeAndABackwardSwPulseThenHomeDoneAndPositionSetToUserDefineOffset_Test7" Id="{258c5fca-fb29-4806-85ec-0c0567cfff16}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdLowLimitModeAndABackwardSwPulseThenHomeDoneAndPositionSetToUserDefineOffset_Test7
VAR_INST
    fbHome : FB_HomeNC(
		AxisRef:=fbAxisRef[7],
		iLimSwStatus:=fbLimSwStatus[7],
		iMotionLogger:=fbMotionLogger[7]
	) := ( Mode:= E_EpicsHomeCmd.LOW_LIMIT );
    fbTestTimer: TON := (IN:=TRUE, PT:=T#5S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
    fExpectedPosition : LREAL := 20.0;
    fActPosition : LREAL;
    bCalibrated: BOOL;
    // reset this when error or homeDone
    bHomingOverride : BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Cyclically called blocks
fbLimSwStatus[7]();
fbMotionLogger[7]();

fbPower[7].Power(
    Enable := TRUE,
    Enable_Positive := bHomingOverride OR fbLimSwStatus[7].LimitForwardEnable,
    Enable_Negative := bHomingOverride OR fbLimSwStatus[7].LimitBackwardEnable,
    Override := 100.0
);

// State machine for negative (backward) limit homing
CASE nTestStep OF
    0: // Wait for power enabled, then start homing
        IF fbPower[7].PowerIsEnabled THEN
            fbHome.Home(Position := fExpectedPosition, BufferMode := MC_BufferMode.MC_Aborting);
            nTestStep := 1;
        END_IF

    1: // Simulate cam pulse to release backward limit
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[7].LimitBackwardEnable := FALSE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 2;
        END_IF

    2: // Simulate restoring backward limit
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[7].LimitBackwardEnable := TRUE;
            nTestStep := 3;
        END_IF

    3: // Wait for homing to complete
        IF fbHome.Done THEN
            nTestStep := 4;
        END_IF

    4: // Test ends; assertions below
END_CASE

// Always cycle axis status, home FB, cam pulsers, and timer
fbAxisRef[7].ReadStatus();
fbHome();
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();

// Assertion and finish
IF nTestStep = 4 THEN
    bCalibrated := fbHome.Done;
    AssertEquals_BOOL(
        Expected := TRUE,
        Actual := fbAxisRef[7].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fExpectedPosition,
        Actual := fbAxisRef[7].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdNoneModeThenSetHomeFlag_Test8" Id="{828068d5-3f4b-4e81-8832-2d3b09781313}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdNoneModeThenSetHomeFlag_Test8
VAR_INST
    fbHome : FB_HomeNC(
		AxisRef:=fbAxisRef[8],
		iLimSwStatus:=fbLimSwStatus[8],
		iMotionLogger:=fbMotionLogger[8]
	):=(Mode:=E_EpicsHomeCmd.NONE);
    fbTestTimer: TON := (IN:=TRUE, PT:=T#5S);
    nTestStep : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Always call these each scan
fbLimSwStatus[8]();
fbMotionLogger[8]();

// State machine for basic home sequence
CASE nTestStep OF
    0: // Enable axis power
        fbPower[8].Power(
            Enable := TRUE,
            Enable_Positive := fbLimSwStatus[8].LimitForwardEnable,
            Enable_Negative := fbLimSwStatus[8].LimitBackwardEnable,
            Override := 100.0
        );
        nTestStep := 1;

    1: // Wait for power to come up, then issue Home command
        IF fbPower[8].PowerIsEnabled THEN
            fbHome.Home(Position := 0.0, BufferMode := MC_BufferMode.MC_Aborting);
            nTestStep := 2;
        END_IF

    2: // Wait for homing to finish
        IF fbHome.Done THEN
            nTestStep := 3;
        END_IF

    3: // Test ends; assertion and finish below
END_CASE

// Required cyclic calls
fbPower[8]();
fbHome();
fbTestTimer(IN := TRUE);

// Assertion & finish logic
IF nTestStep = 3 THEN
    // You may add validation here (homed position, calibrated flag, etc.) if required
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenHomeCmdSetToHighLimitAndHighLimitPulseThenSetHomeDoneAndPositionToUserDefineOffset_Test9" Id="{d6dfc9cc-8559-4032-bc50-ad12f2b74624}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdSetToHighLimitAndHighLimitPulseThenSetHomeDoneAndPositionToUserDefineOffset_Test9
VAR_INST
    fbHome : FB_HomeNC(
		AxisRef:=fbAxisRef[9],
		iLimSwStatus:=fbLimSwStatus[9],
		iMotionLogger:=fbMotionLogger[9]
	):=(Mode:=E_EpicsHomeCmd.HIGH_LIMIT);
	
    fbTestTimer: TON := (IN:=TRUE, PT:=T#5S);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    nTestStep : INT;
    fExpectedPosition : LREAL := 20.0;
    fActPosition : LREAL;
    bCalibrated: BOOL;
    // reset this when error or homeDone
    bHomingOverride : BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Cyclic calls: always invoked every scan
fbLimSwStatus[9]();
fbMotionLogger[9]();
fbPower[9].Power(
    Enable := TRUE,
    Enable_Positive := bHomingOverride OR fbLimSwStatus[9].LimitForwardEnable,
    Enable_Negative := bHomingOverride OR fbLimSwStatus[9].LimitBackwardEnable,
    Override := 100.0
);

// Homing state machine
CASE nTestStep OF
    0: // Wait for power enabled, then start homing command
        IF fbPower[9].PowerIsEnabled THEN
            fbHome.Home(Position := fExpectedPosition, BufferMode := MC_BufferMode.MC_Aborting);
            nTestStep := 1;
        END_IF

    1: // Simulate cam pulse to clear forward limit
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[9].LimitForwardEnable := FALSE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := 2;
        END_IF

    2: // Simulate restoring forward limit
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[9].LimitForwardEnable := TRUE;
            nTestStep := 3;
        END_IF

    3: // Wait for homing to complete
        IF fbHome.Done THEN
            nTestStep := 4;
        END_IF

    4: // Test ends, assertions handled below
END_CASE

// Always called each scan
fbAxisRef[9].ReadStatus();
fbHome();
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();

// Assertion and finish
IF nTestStep = 4 THEN
    bCalibrated := fbHome.Done;
    AssertEquals_BOOL(
        Expected := TRUE,
        Actual := fbAxisRef[9].Status.Homed,
        Message := 'Axis not calibrated #1'
    );
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fExpectedPosition,
        Actual := fbAxisRef[9].NcToPlc.ActPos,
        Message := 'Position is not the expected #2'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdNegativeBacklashCompensationActiveThenReverseMoveIsCompensated_Test10" Id="{ed4242b5-1f08-417f-b32f-5a900afbf462}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdNegativeBacklashCompensationActiveThenReverseMoveIsCompensated_Test10
VAR_INST
    // Subjects under tests
    fbBacklashCompensation : FB_BacklashCompensationNC(AxisRef := fbAxisRef[10],  iMotionLogger:= fbMotionLogger[10]);
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[10],  iMotionLogger:= fbMotionLogger[10]);
    // Backalsh is testing on simulated NC axis in Homing and PTP
    fbTestTimer : TON := (PT := T#5S, IN := TRUE);
    nTestStep : INT;;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Must be called cyclically
fbPower[10].Power(
    Enable := TRUE,
    Enable_Positive := fbLimSwStatus[10].LimitForwardEnable,
    Enable_Negative := fbLimSwStatus[10].LimitBackwardEnable,
    Override := 100
);

CASE nTestStep OF
    // Enable compensation, but status should still be OFF initially
    0:
        fbBacklashCompensation.EnableBacklashCompensation(UserEnable := TRUE, Compensation := -4.0);
        nTestStep := 1;
	1:
		fbBacklashCompensation.BacklashCompensation(Enable := TRUE, RampVelo := 10.0);
		nTestStep := 2;
    2:
        AssertTrue(
            Condition := fbBacklashCompensation.Status,
            Message := 'Backlash compensation must be enabled #2'
        );
        nTestStep := 3;

    // Start negative move (direction should not apply backlash compensation here)
    3:
        IF fbPower[10].PowerIsEnabled THEN
            fbMoveAbsolute.MoveAbsolute(
                Position := -10.0,
                Velocity := 100,
                Acceleration := 200,
                Deceleration := 200
            );
            nTestStep := 4;
        END_IF

    // Assert compensation does not apply after negative move
   4:
        IF fbMoveAbsolute.Done THEN
            AssertTrue(
                Condition := (fbAxisRef[10].NcToPlc.ActPos - fbAxisRef[10].NcToPlc.ActPosWithoutPosCorrection) = 0,
                Message := 'No Backlash compensation in this direction #3'
            );
            nTestStep := 5;
        END_IF

    // Start reverse move (should apply backlash compensation)
   5:
        fbMoveAbsolute.MoveAbsolute(
            Position := 20.0,
            Velocity := 100,
            Acceleration := 200,
            Deceleration := 200
        );
        nTestStep := 6;

    // Assert compensation is applied after reverse move
   6:
        IF fbMoveAbsolute.Done THEN
            AssertTrue(
                Condition := (fbAxisRef[10].NcToPlc.ActPos - fbAxisRef[10].NcToPlc.ActPosWithoutPosCorrection) = 4,
                Message := 'Current backlash must be 4 #4'
            );
            nTestStep := 7;
        END_IF

END_CASE

// Required cyclic calls
fbBacklashCompensation();
fbMoveAbsolute();
fbTestTimer();

// Final assertion and finish
IF nTestStep = 7 THEN
    AssertTrue(
        Condition := fbBacklashCompensation.Status,
        Message := 'Backlash compensation must stay enabled after absolute move #5'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdPositiveBacklashCompensationActiveThenReverseMoveIsCompensated_Test11" Id="{9c1a4bce-ba95-4b9d-bd69-46b6e3327f0a}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdPositiveBacklashCompensationActiveThenReverseMoveIsCompensated_Test11
VAR_INST
    // Subjects under test
    fbBacklashCompensation : FB_BacklashCompensationNC(AxisRef := fbAxisRef[11],  iMotionLogger:= fbMotionLogger[11]);
	fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[11],  iMotionLogger:= fbMotionLogger[11]);
    // Backalsh is testing on simulated NC axis in Homing and PTP
    fbTestTimer : TON := (PT := T#5S, IN := TRUE);
    nTestStep : INT;

    


END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Must be called cyclically
fbPower[11].Power(
    Enable := TRUE,
    Enable_Positive := fbLimSwStatus[11].LimitForwardEnable,
    Enable_Negative := fbLimSwStatus[11].LimitBackwardEnable,
    Override := 100
);

CASE nTestStep OF
    // Enable compensation, but status should still be OFF initially
    0:
        fbBacklashCompensation.EnableBacklashCompensation(UserEnable := TRUE, Compensation := 4.0);
        nTestStep := 1;
	1:
		fbBacklashCompensation.BacklashCompensation(Enable := TRUE, RampVelo := 10.0);
		nTestStep := 2;
    2:
        AssertTrue(
            Condition := fbBacklashCompensation.Status,
            Message := 'Backlash compensation must be enabled #2'
        );
        nTestStep := 3;

    // Start negative move (direction should not apply backlash compensation here)
    3:
        IF fbPower[11].PowerIsEnabled THEN
            fbMoveAbsolute.MoveAbsolute(
                Position :=50.0,
                Velocity := 100,
                Acceleration := 200,
                Deceleration := 200
            );
            nTestStep := 4;
        END_IF

    // Assert compensation does not apply after negative move
   4:
        IF fbMoveAbsolute.Done THEN
            AssertTrue(
                Condition := (fbAxisRef[11].NcToPlc.ActPos - fbAxisRef[11].NcToPlc.ActPosWithoutPosCorrection) = 0,
                Message := 'No Backlash compensation in this direction #3'
            );
            nTestStep := 5;
        END_IF

    // Start reverse move (should apply backlash compensation)
   5:
        fbMoveAbsolute.MoveAbsolute(
            Position := 25.0,
            Velocity := 100,
            Acceleration := 200,
            Deceleration := 200
        );
        nTestStep := 6;

    // Assert compensation is applied after reverse move
   6:
        IF fbMoveAbsolute.Done THEN
            AssertTrue(
                Condition := (fbAxisRef[11].NcToPlc.ActPos - fbAxisRef[11].NcToPlc.ActPosWithoutPosCorrection) = 4,
                Message := 'Current backlash must be 4 #4'
            );
            nTestStep := 7;
        END_IF

END_CASE

// Required cyclic calls
fbBacklashCompensation();
fbMoveAbsolute();
fbTestTimer();

// Final assertion and finish
IF nTestStep = 7 THEN
    AssertTrue(
        Condition := fbBacklashCompensation.Status,
        Message := 'Backlash compensation must stay enabled after absolute move #5'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenPowerIsEnabledAbsoluteMoveIfResetThenMoveIsAbortedAndResetDoneIsRetained_Test16" Id="{92ac79f2-3e81-4622-8597-aa483d9ef4da}">
      <Declaration><![CDATA[METHOD PRIVATE GivenPowerIsEnabledAbsoluteMoveIfResetThenMoveIsAbortedAndResetDoneIsRetained_Test16
VAR_INST
    // Subjects under test
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[16], iMotionLogger:= fbMotionLogger[16]);
    fbReset : FB_ResetNC(AxisRef := fbAxisRef[16], iMotionLogger:= fbMotionLogger[16]);
    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    fbInMotionTimer : TON := (PT := T#1S, IN := FALSE);
    nTestStateStep : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Cyclic power logic
fbPower[16].Power(
    Enable := TRUE,
    Enable_Positive := fbLimSwStatus[16].LimitForwardEnable,
    Enable_Negative := fbLimSwStatus[16].LimitBackwardEnable,
    Override := 100
);

// State machine for move + reset abort
CASE nTestStateStep OF
    0: // Wait for axis power before starting move
        IF fbPower[16].PowerIsEnabled THEN
            nTestStateStep := 1;
        END_IF

    1: // Issue move absolute
        fbMoveAbsolute.MoveAbsolute(
            Position := 100,
            Velocity := 100,
            Acceleration := 50,
            Deceleration := 50
        );
        nTestStateStep := 2;

    2: // Wait for axis to become busy; start timer
        IF fbMoveAbsolute.Busy THEN
            fbInMotionTimer.IN := TRUE;
            nTestStateStep := 3;
        END_IF

    3: // When timer elapses, send Reset to abort move
        IF fbInMotionTimer.Q THEN
            fbReset.Reset();
            fbInMotionTimer.IN := FALSE;
            nTestStateStep := 4;
        END_IF

    4: // Wait for reset to be done (move abort completion)
        IF fbReset.Done THEN
            nTestStateStep := 5;
        END_IF
END_CASE

// Cyclic calls for status and timers
fbInMotionTimer();
fbAxisRef[16].ReadStatus();
fbMoveAbsolute();
fbReset();
fbTestTimer();

// Assertion and finish logic
IF nTestStateStep = 5 THEN
    AssertTrue(
        Condition := fbMoveAbsolute.Aborted,
        Message := 'Expected CommandAborted'
    );
    AssertTrue(
        Condition := fbReset.Done,
        Message := 'Expected Reset.Done'
    );
    AssertFalse(
        Condition := fbReset.Busy,
        Message := 'Expected Reset not busy'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenPowerIsEnabledAndAbsoluteMoveStartedIfHaltSignalThenMoveIsAbortedAndHaltDoneIsRetained_Test15" Id="{b69b45e8-b2d6-406e-88d9-5d68b04e79a5}">
      <Declaration><![CDATA[METHOD PRIVATE GivenPowerIsEnabledAndAbsoluteMoveStartedIfHaltSignalThenMoveIsAbortedAndHaltDoneIsRetained_Test15
VAR_INST
    // Subjects under test
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[15], iMotionLogger:= fbMotionLogger[15]);
    fbHalt : FB_HaltNC(AxisRef := fbAxisRef[15], iMotionLogger:= fbMotionLogger[15]);
    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    fbInMotionTimer : TON := (PT := T#1S, IN := FALSE);
    nTestStateStep : INT;;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Always called per scan
fbPower[15].Power(
    Enable := TRUE,
    Enable_Positive := fbLimSwStatus[15].LimitForwardEnable,
    Enable_Negative := fbLimSwStatus[15].LimitBackwardEnable,
    Override := 100
);

// State machine for move + halt
CASE nTestStateStep OF
    0 : // Wait for power-up before starting move
        IF fbPower[15].PowerIsEnabled THEN
            nTestStateStep := 1;
        END_IF

    1 : // Start move
        fbMoveAbsolute.MoveAbsolute(
            Position := 100,
            Velocity := 100,
            Acceleration := 50,
            Deceleration := 50
        );
        nTestStateStep := 2;

    2 : // Wait until move system is busy, then start in-motion timer
        IF fbMoveAbsolute.Busy THEN
            fbInMotionTimer.IN := TRUE;
            nTestStateStep := 3;
        END_IF

    3 : // When timer triggers, send Halt
        IF fbInMotionTimer.Q THEN
            fbHalt.Halt(
                Deceleration := 100,
                Jerk := 0
            );
            fbInMotionTimer.IN := FALSE;
            nTestStateStep := 4;
        END_IF

    4 : // Wait for halt done (move abort confirmation)
        IF fbHalt.Done THEN
            nTestStateStep := 5;
        END_IF

    5 : // Test ends; assertions below
        // (do nothing)
END_CASE

// Cyclic calls
fbTestTimer();
fbInMotionTimer();
fbAxisRef[15].ReadStatus();
fbMoveAbsolute();
fbHalt();

// Test result and finish logic
IF nTestStateStep = 5 THEN
    AssertTrue(
        Condition := fbMoveAbsolute.Aborted,
        Message := 'Expected CommandAborted'
    );
    AssertTrue(
        Condition := fbHalt.Done,
        Message := 'Expected Done'
    );
    AssertFalse(
        Condition := fbHalt.Busy,
        Message := 'Expected not busy'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenPowerIsEnabledAndCompletedAbsoluteMoveThenMoveAbsoluteDoneStatusRetained_Test14" Id="{d6224050-ec2d-4785-a811-d10c9555be8b}">
      <Declaration><![CDATA[METHOD PRIVATE GivenPowerIsEnabledAndCompletedAbsoluteMoveThenMoveAbsoluteDoneStatusRetained_Test14
VAR_INST
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[14], iMotionLogger:= fbMotionLogger[14]);
    nTestStateStep : INT;
    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    fExpectedPosition: LREAL := 50.0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// Always call required power block
fbPower[14].Power(
    Enable := TRUE,
    Enable_Positive := fbLimSwStatus[14].LimitForwardEnable,
    Enable_Negative := fbLimSwStatus[14].LimitBackwardEnable,
    Override := 100
);

// Stepwise state machine for the move
CASE nTestStateStep OF
    0 : // Wait for power-on before starting move
        IF fbPower[14].PowerIsEnabled THEN
            nTestStateStep := 1;
        END_IF

    1 : // Issue Move Absolute command
        fbMoveAbsolute.MoveAbsolute(
            Position := fExpectedPosition,   // Substituted value for clarity
            Velocity := 500,
            Acceleration := 1000,
            Deceleration := 1000
        );
        nTestStateStep := 2;

    2 : // Wait until move finishes
        IF fbMoveAbsolute.Done THEN
            nTestStateStep := 3;
        END_IF
END_CASE

// Cyclically called per scan
fbTestTimer();
fbAxisRef[14].ReadStatus();
fbMoveAbsolute();

// Final assertion and test finish
IF nTestStateStep = 3 THEN
    AssertEquals_LREAL(
        Delta := 0.001,
        Expected := fExpectedPosition,
        Actual := fbAxisRef[14].NcToPlc.ActPos,
        Message := 'Position is not the expected #1'
    );
    TEST_FINISHED();

ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );
    TEST_FINISHED();
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>